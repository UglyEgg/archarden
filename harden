#!/usr/bin/env bash
# SPDX-License-Identifier: AGPL-3.0-or-later
# Copyright (c) 2025 Richard Majewski
set -eEuo pipefail

PHASE0_LOG="/var/log/vps-harden.phase0.log"
PHASE1_LOG="/var/log/vps-harden.phase1.log"
LOG_FILE="${PHASE0_LOG}"
CURRENT_PHASE="phase0"
SSHD_CONFIG_DIR="/etc/ssh/sshd_config.d"
SSHD_HARDENING_DROPIN="${SSHD_CONFIG_DIR}/10-hardening.conf"
SSHD_CRYPTO_DROPIN="${SSHD_CONFIG_DIR}/10-crypto-hardening.conf"
BACKUP_ROOT_BASE="/root/archarden-backups"
SSH_HOSTKEY_BACKUP_CATEGORY="ssh-hostkeys"
for arg in "$@"; do
    if [[ "${arg}" == "--resume" ]]; then
        LOG_FILE="${PHASE1_LOG}"
        CURRENT_PHASE="phase1"
        break
    fi
done

DEFAULT_INSTALL_PREFIX="/usr/local/lib/vps-harden"
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
if [[ ! -f "${SCRIPT_DIR}/lib/utils.sh" ]]; then
    FALLBACK_DIR="${DEFAULT_INSTALL_PREFIX}"
    if [[ -f "${FALLBACK_DIR}/lib/utils.sh" ]]; then
        SCRIPT_DIR="${FALLBACK_DIR}"
    else
        printf 'Required helper not found: %s\n' "${SCRIPT_DIR}/lib/utils.sh" >&2
        exit 1
    fi
fi
CONFIG_DIR="${SCRIPT_DIR}/config"
TEMPLATES_DIR="${SCRIPT_DIR}/templates"
source "${SCRIPT_DIR}/lib/utils.sh"

DRY_RUN=0
ENABLE_FAIL2BAN=1
ENABLE_FIREWALL=1
SKIP_FIREWALL_ENABLE=0
KEEP_SSH_22=0
RESTRICT_SSH_CIDR=""
USER_NAME=""
USER_HOME=""
PODMAN_USER="podmin"
PODMAN_HOME=""
PODMAN_UID=""
ENSURED_PODMIN_MANAGER=0
PUBKEY_FILE=""
PUBKEY_VALUE=""
ENABLE_AUDITD=0
SYSTEM_HOSTNAME=""
SSH_PORT=2122
SSH_CONNECTION_INFO=""
GRUB_LTS_ENTRY="Advanced options for Arch Linux>Arch Linux, with Linux linux-lts"
GRUB_CONFIG_PATH="/boot/grub/grub.cfg"
INSTALL_PREFIX="${DEFAULT_INSTALL_PREFIX}"
INSTALL_BIN="/usr/local/bin/vps-harden"
STATE_DIR="/var/lib/vps-harden"
PENDING_ARGS_FILE="${STATE_DIR}/pending_args"
PERSISTED_PUBKEY_FILE="${STATE_DIR}/pubkey"
RUN_ID_FILE="${STATE_DIR}/run_id"
CONTINUE_SERVICE="/etc/systemd/system/vps-harden-continue.service"
CONTINUE_SERVICE_TEMPLATE="${TEMPLATES_DIR}/systemd/vps-harden-continue.service"
FINAL_LOG_FILE=""
RUN_ID=""
BACKUP_ROOT=""
BACKUP_ARCHIVE=""
README_MARKER="<!-- managed: archarden -->"
GOTIFY_PORT=8090
WG_INTERFACE_ADDRESS=""
WG_LISTEN_PORT=""
WG_DNS=""
WG_PEERS=()
WIREGUARD_CONFIG_LOADED=0
WIREGUARD_PEER_NAMES=()
WIREGUARD_PEER_IPS=()
WIREGUARD_SERVER_IP=""
WIREGUARD_SERVER_ALLOWED_IP=""
PODMAN_API_GROUP="podman-api"

clear_pending_state() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would clear pending state at ${PENDING_ARGS_FILE}"
        return
    fi
    rm -f "${PENDING_ARGS_FILE}"
}

ensure_backup_root() {
    if [[ -z "${BACKUP_ROOT:-}" ]]; then
        log_error "BACKUP_ROOT is not set; initialize run context before creating backups."
        exit 1
    fi
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would ensure backup root at ${BACKUP_ROOT}"
        return
    fi
    run_cmd "install -d -m 0700 -o root -g root \"${BACKUP_ROOT_BASE}\""
    run_cmd "install -d -m 0700 -o root -g root \"${BACKUP_ROOT}\""
}

initialize_run_context() {
    local ts existing_run_id=""
    if [[ -z "${RUN_ID:-}" && ${RESUME_MODE:-0} -eq 1 && -s "${RUN_ID_FILE}" ]]; then
        existing_run_id=$(cat "${RUN_ID_FILE}")
        RUN_ID="${existing_run_id}"
        log_info "Resuming with existing run id ${RUN_ID}"
    fi
    if [[ -z "${RUN_ID:-}" ]]; then
        ts=$(date -u '+%Y%m%d-%H%M%SZ')
        RUN_ID="${ts}"
        log_info "Generated run id ${RUN_ID} for this execution"
    fi
    BACKUP_ROOT="${BACKUP_ROOT_BASE}/${RUN_ID}"
    BACKUP_ARCHIVE="/root/archarden-backups-${RUN_ID}.tar.gz"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would record run id at ${RUN_ID_FILE} and ensure backup root ${BACKUP_ROOT}"
        return
    fi
    run_cmd "install -d -m 0700 -o root -g root \"${STATE_DIR}\""
    run_cmd "install -m 0600 /dev/null \"${RUN_ID_FILE}\""
    echo "${RUN_ID}" > "${RUN_ID_FILE}"
    ensure_backup_root
}

ensure_fail2ban_sshd_local() {
    local target=/etc/fail2ban/jail.d/sshd.local
    local tmp_base tmp_other tmp_out current_section section_lower

    tmp_base=$(mktemp)
    tmp_other=$(mktemp)
    tmp_out=$(mktemp)

    sed "s/__SSH_PORT__/${SSH_PORT}/g" "${CONFIG_DIR}/fail2ban_sshd.local" > "${tmp_base}"

    if [[ -f "${target}" ]]; then
        current_section=""
        while IFS= read -r line || [[ -n "${line}" ]]; do
            if [[ "${line}" =~ ^\[([^]]+)\] ]]; then
                current_section="${BASH_REMATCH[1]}"
            fi
            section_lower=${current_section,,}
            if [[ "${section_lower}" != "default" && "${section_lower}" != "sshd" ]]; then
                echo "${line}" >>"${tmp_other}"
            fi
        done < "${target}"
    fi

    cat "${tmp_base}" > "${tmp_out}"
    if [[ -s "${tmp_other}" ]]; then
        echo >>"${tmp_out}"
        cat "${tmp_other}" >>"${tmp_out}"
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_base}" "${tmp_other}" "${tmp_out}"
    run_cmd "chown root:root ${target}"
}

ensure_fail2ban_defaults_local() {
    local target=/etc/fail2ban/jail.local
    local tmp_base tmp_other tmp_out current_section section_lower

    tmp_base=$(mktemp)
    tmp_other=$(mktemp)
    tmp_out=$(mktemp)

    cat "${CONFIG_DIR}/fail2ban_jail.local" > "${tmp_base}"

    if [[ -f "${target}" ]]; then
        current_section=""
        while IFS= read -r line || [[ -n "${line}" ]]; do
            if [[ "${line}" =~ ^\[([^]]+)\] ]]; then
                current_section="${BASH_REMATCH[1]}"
            fi
            section_lower=${current_section,,}
            if [[ "${section_lower}" != "default" ]]; then
                echo "${line}" >>"${tmp_other}"
            fi
        done < "${target}"
    fi

    cat "${tmp_base}" > "${tmp_out}"
    if [[ -s "${tmp_other}" ]]; then
        echo >>"${tmp_out}"
        cat "${tmp_other}" >>"${tmp_out}"
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_base}" "${tmp_other}" "${tmp_out}"
    run_cmd "chown root:root ${target}"
}

run_status_capture() {
    local label="$1"; shift
    local err_file output rc err_msg
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would run: $*"
        return 0
    fi
    err_file=$(mktemp)
    set +e
    output=$("$@" 2>"${err_file}")
    rc=$?
    set -e
    if [[ ${rc} -ne 0 ]]; then
        err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
        log_warn "${label} failed: ${err_msg:-unknown}"
    else
        while IFS= read -r line || [[ -n "${line}" ]]; do
            log_info "${label}: ${line}"
        done <<<"${output:-ok}"
    fi
    rm -f "${err_file}"
}

configure_fail2ban() {
    if [[ ${ENABLE_FAIL2BAN} -eq 0 ]]; then
        log_warn "Fail2ban disabled by flag"
        return
    fi
    backup_file /etc/fail2ban/jail.local
    backup_file /etc/fail2ban/jail.d/sshd.local
    run_cmd "install -d -m 0755 /etc/fail2ban/jail.d"
    ensure_fail2ban_defaults_local
    ensure_fail2ban_sshd_local
    run_cmd "systemctl enable --now fail2ban.service"
    run_cmd "systemctl restart fail2ban.service"
    if command -v ufw >/dev/null 2>&1; then
        if ! ufw status 2>/dev/null | grep -qi "Status: active"; then
            log_warn "ufw is not active; banaction=ufw will not take effect until ufw is enabled"
        else
            run_status_capture "ufw status numbered" ufw status numbered
        fi
    fi
    run_status_capture "fail2ban-client status" fail2ban-client status
    run_status_capture "fail2ban-client status sshd" fail2ban-client status sshd
}

configure_hostname() {
    if [[ -z "${SYSTEM_HOSTNAME}" ]]; then
        return
    fi
    run_cmd "hostnamectl set-hostname ${SYSTEM_HOSTNAME}"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        return
    fi
    log_info "Hostname set to ${SYSTEM_HOSTNAME}"
}

configure_journald() {
    backup_file /etc/systemd/journald.conf
    write_file_atomic /etc/systemd/journald.conf < "${CONFIG_DIR}/journald.conf"
    run_cmd "systemctl restart systemd-journald"
}

configure_podman_templates() {
    local dest_dir=/usr/share/vps-harden/templates/containers
    write_file_atomic /usr/share/vps-harden/README <<'EOT'
Podman templates installed by vps-harden.
EOT
    write_file_atomic "${dest_dir}/nginx-proxy-manager.container" < "${TEMPLATES_DIR}/containers/nginx-proxy-manager.container"
    write_file_atomic "${dest_dir}/podman-run-npm.sh" < "${TEMPLATES_DIR}/containers/podman-run-npm.sh"
    write_file_atomic "${dest_dir}/gotify.container" < "${TEMPLATES_DIR}/containers/gotify.container"
    write_file_atomic "${dest_dir}/uptime-kuma.container" < "${TEMPLATES_DIR}/containers/uptime-kuma.container"
    write_file_atomic "${dest_dir}/podman-run-gotify.sh" < "${TEMPLATES_DIR}/containers/podman-run-gotify.sh"
    run_cmd "chmod +x ${dest_dir}/podman-run-npm.sh"
    run_cmd "chmod +x ${dest_dir}/podman-run-gotify.sh"
}

ensure_containers_runtime_config() {
    local target="$1" owner="${2:-root}" group="${3:-root}"
    local runtime_line='runtime = "runc"'
    local tmp in_engine=0 runtime_set=0 found_engine=0
    tmp=$(mktemp)

    run_cmd "install -d -m 0755 -o ${owner} -g ${group} $(dirname "${target}")"

    if [[ -f "${target}" ]]; then
        while IFS= read -r line || [[ -n "${line}" ]]; do
            if [[ "${line}" =~ ^\[.*\] ]]; then
                if [[ ${in_engine} -eq 1 && ${runtime_set} -eq 0 ]]; then
                    echo "${runtime_line}" >>"${tmp}"
                fi
                in_engine=0
            fi
            if [[ "${line}" =~ ^\[engine\] ]]; then
                found_engine=1
                in_engine=1
                runtime_set=0
            fi
            if [[ ${in_engine} -eq 1 && "${line}" =~ ^runtime[[:space:]]*= ]]; then
                line=${runtime_line}
                runtime_set=1
            fi
            echo "${line}" >>"${tmp}"
        done < "${target}"
    fi

    if [[ ${in_engine} -eq 1 && ${runtime_set} -eq 0 ]]; then
        echo "${runtime_line}" >>"${tmp}"
    fi

    if [[ ${found_engine} -eq 0 ]]; then
        [[ -s "${tmp}" ]] && echo >>"${tmp}"
        {
            echo "[engine]"
            echo "${runtime_line}"
        } >>"${tmp}"
    fi

    write_file_atomic "${target}" < "${tmp}"
    rm -f "${tmp}"
    if [[ "${owner}" != "root" || "${group}" != "root" ]]; then
        run_cmd "chown ${owner}:${group} ${target}"
    fi
}

configure_podman_runtime() {
    local podmin_home
    podmin_home="${PODMAN_HOME:-$(getent passwd "${PODMAN_USER}" | cut -d: -f6)}"
    if [[ -z "${podmin_home}" ]]; then
        if [[ ${DRY_RUN} -eq 1 ]]; then
            podmin_home="/home/${PODMAN_USER}"
        else
            log_error "Unable to determine home for ${PODMAN_USER}"
            exit 1
        fi
    fi
    ensure_containers_runtime_config /etc/containers/containers.conf root root
    ensure_containers_runtime_config "${podmin_home}/.config/containers/containers.conf" "${PODMAN_USER}" "${PODMAN_USER}"
}

ensure_quadlet_generator() {
    local generator_dir generator_path
    generator_dir=$(systemd-path user-generators 2>/dev/null || true)
    if [[ -z "${generator_dir}" ]]; then
        generator_dir="/usr/lib/systemd/user-generators"
    fi
    generator_path="${generator_dir%/}/podman-system-generator"

    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would check for podman quadlet generator at ${generator_path}"
        return 0
    fi

    if [[ ! -x "${generator_path}" ]]; then
        log_warn "Podman quadlet generator not found at ${generator_path}; rootless quadlet services cannot start"
        log_warn "Install podman with quadlet support (podman-quadlet or podman package including quadlet) and rerun the hardener"
        return 1
    fi
    return 0
}

ensure_npm_quadlet() {
    local user_home systemd_dir target input tmp_out
    user_home="${PODMAN_HOME:-$(getent passwd "${PODMAN_USER}" | cut -d: -f6)}"
    if [[ -z "${user_home}" ]]; then
        log_error "Unable to determine home for ${PODMAN_USER}"
        exit 1
    fi
    systemd_dir="${user_home}/.config/containers/systemd"
    target="${systemd_dir}/nginx-proxy-manager.container"
    input="${target}"
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${user_home}/.config ${user_home}/.config/containers ${systemd_dir}"
    if [[ ! -f "${input}" ]]; then
        input="${TEMPLATES_DIR}/containers/nginx-proxy-manager.container"
    fi

    tmp_out=$(mktemp)
    local in_container=0 saw_memory=0 saw_pids=0 saw_podmanargs=0
    local in_install=0 saw_install=0 saw_install_wanted_by=0 saw_install_default_target=0
    local -a required_ports=("127.0.0.1:8181:81" "127.0.0.1:8080:80" "127.0.0.1:8443:443")
    declare -A port_seen
    for port in "${required_ports[@]}"; do
        port_seen["${port}"]=0
    done

    while IFS= read -r line || [[ -n "${line}" ]]; do
        if [[ "${line}" =~ ^\[.*\] ]]; then
            if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
                echo "WantedBy=default.target" >>"${tmp_out}"
                saw_install_default_target=1
            fi
            if [[ ${in_container} -eq 1 ]]; then
                for port in "${required_ports[@]}"; do
                    if [[ ${port_seen[${port}]} -eq 0 ]]; then
                        echo "PublishPort=${port}" >>"${tmp_out}"
                        port_seen["${port}"]=1
                    fi
                done
                if [[ ${saw_memory} -eq 0 ]]; then
                    echo "Memory=512M" >>"${tmp_out}"
                fi
                if [[ ${saw_pids} -eq 0 ]]; then
                    echo "PidsLimit=512" >>"${tmp_out}"
                fi
                if [[ ${saw_podmanargs} -eq 0 ]]; then
                    echo "PodmanArgs=--memory-swap=1G" >>"${tmp_out}"
                fi
            fi
            in_container=0
            in_install=0
        fi

        if [[ "${line}" =~ ^\[Install\]$ ]]; then
            in_install=1
            saw_install=1
            saw_install_wanted_by=0
        fi

        if [[ ${in_container} -eq 1 ]]; then
            if [[ "${line}" =~ ^PublishPort= ]]; then
                local port_value
                port_value=${line#PublishPort=}
                if [[ "${port_value}" == "80:80" || "${port_value}" == "443:443" ]]; then
                    continue
                fi
                if [[ -n "${port_seen[${port_value}]+x}" ]]; then
                    if [[ ${port_seen[${port_value}]} -eq 1 ]]; then
                        continue
                    fi
                    port_seen["${port_value}"]=1
                fi
                echo "PublishPort=${port_value}" >>"${tmp_out}"
                continue
            fi

            if [[ "${line}" =~ ^Memory= ]]; then
                if [[ ${saw_memory} -eq 1 ]]; then
                    continue
                fi
                line="Memory=512M"
                saw_memory=1
            fi
            if [[ "${line}" =~ ^PidsLimit= ]]; then
                if [[ ${saw_pids} -eq 1 ]]; then
                    continue
                fi
                line="PidsLimit=512"
                saw_pids=1
            fi
            if [[ "${line}" =~ ^Network= ]]; then
                if [[ "${line}" == "Network=host" ]]; then
                    line="Network=slirp4netns"
                fi
            fi
            if [[ "${line}" =~ ^PodmanArgs= ]]; then
                if [[ ${saw_podmanargs} -eq 1 ]]; then
                    continue
                fi
                saw_podmanargs=1
                if [[ "${line}" != *"--memory-swap=1G"* ]]; then
                    line="${line} --memory-swap=1G"
                fi
            fi
        fi

        if [[ ${in_install} -eq 1 && "${line}" =~ ^WantedBy= ]]; then
            saw_install_wanted_by=1
            if [[ "${line#WantedBy=}" == *"default.target"* ]]; then
                saw_install_default_target=1
            fi
        fi

        echo "${line}" >>"${tmp_out}"

        if [[ "${line}" == "[Container]" ]]; then
            in_container=1
            saw_memory=0
            saw_pids=0
            saw_podmanargs=0
            for port in "${required_ports[@]}"; do
                port_seen["${port}"]=0
            done
        fi
    done < "${input}"

    if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    if [[ ${in_container} -eq 1 ]]; then
        for port in "${required_ports[@]}"; do
            if [[ ${port_seen[${port}]} -eq 0 ]]; then
                echo "PublishPort=${port}" >>"${tmp_out}"
            fi
        done
        if [[ ${saw_memory} -eq 0 ]]; then
            echo "Memory=512M" >>"${tmp_out}"
        fi
        if [[ ${saw_pids} -eq 0 ]]; then
            echo "PidsLimit=512" >>"${tmp_out}"
        fi
        if [[ ${saw_podmanargs} -eq 0 ]]; then
            echo "PodmanArgs=--memory-swap=1G" >>"${tmp_out}"
        fi
    fi

    if [[ ${saw_install} -eq 0 ]]; then
        echo >>"${tmp_out}"
        echo "[Install]" >>"${tmp_out}"
        echo "WantedBy=default.target" >>"${tmp_out}"
    elif [[ ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_out}"
    run_cmd "chown ${PODMAN_USER}:${PODMAN_USER} ${target}"
    run_cmd "chmod 0644 ${target}"
}

ensure_gotify_quadlet() {
    local user_home systemd_dir target input tmp_out
    user_home="${PODMAN_HOME:-$(getent passwd "${PODMAN_USER}" | cut -d: -f6)}"
    if [[ -z "${user_home}" ]]; then
        log_error "Unable to determine home for ${PODMAN_USER}"
        exit 1
    fi
    systemd_dir="${user_home}/.config/containers/systemd"
    target="${systemd_dir}/gotify.container"
    input="${target}"
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${user_home}/.config ${user_home}/.config/containers ${systemd_dir}"
    if [[ ! -f "${input}" ]]; then
        input="${TEMPLATES_DIR}/containers/gotify.container"
    fi

    tmp_out=$(mktemp)
    local in_container=0 saw_memory=0 saw_pids=0
    local in_install=0 saw_install=0 saw_install_wanted_by=0 saw_install_default_target=0

    while IFS= read -r line || [[ -n "${line}" ]]; do
        if [[ "${line}" =~ ^\[.*\] ]]; then
            if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
                echo "WantedBy=default.target" >>"${tmp_out}"
                saw_install_default_target=1
            fi
            if [[ ${in_container} -eq 1 ]]; then
                if [[ ${saw_memory} -eq 0 ]]; then
                    echo "Memory=128M" >>"${tmp_out}"
                fi
                if [[ ${saw_pids} -eq 0 ]]; then
                    echo "PidsLimit=256" >>"${tmp_out}"
                fi
            fi
            in_container=0
            in_install=0
        fi

        if [[ "${line}" =~ ^\[Install\]$ ]]; then
            in_install=1
            saw_install=1
            saw_install_wanted_by=0
        fi

        if [[ ${in_container} -eq 1 ]]; then
            if [[ "${line}" =~ ^Memory= ]]; then
                if [[ ${saw_memory} -eq 1 ]]; then
                    continue
                fi
                line="Memory=128M"
                saw_memory=1
            fi
            if [[ "${line}" =~ ^PidsLimit= ]]; then
                if [[ ${saw_pids} -eq 1 ]]; then
                    continue
                fi
                line="PidsLimit=256"
                saw_pids=1
            fi
        fi

        if [[ ${in_install} -eq 1 && "${line}" =~ ^WantedBy= ]]; then
            saw_install_wanted_by=1
            if [[ "${line#WantedBy=}" == *"default.target"* ]]; then
                saw_install_default_target=1
            fi
        fi

        echo "${line}" >>"${tmp_out}"

        if [[ "${line}" == "[Container]" ]]; then
            in_container=1
            saw_memory=0
            saw_pids=0
        fi
    done < "${input}"

    if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    if [[ ${in_container} -eq 1 ]]; then
        if [[ ${saw_memory} -eq 0 ]]; then
            echo "Memory=128M" >>"${tmp_out}"
        fi
        if [[ ${saw_pids} -eq 0 ]]; then
            echo "PidsLimit=256" >>"${tmp_out}"
        fi
    fi

    if [[ ${saw_install} -eq 0 ]]; then
        echo >>"${tmp_out}"
        echo "[Install]" >>"${tmp_out}"
        echo "WantedBy=default.target" >>"${tmp_out}"
    elif [[ ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_out}"
    run_cmd "chown ${PODMAN_USER}:${PODMAN_USER} ${target}"
    run_cmd "chmod 0644 ${target}"
}

ensure_uptime_kuma_quadlet() {
    local user_home systemd_dir target input tmp_out
    user_home="${PODMAN_HOME:-$(getent passwd "${PODMAN_USER}" | cut -d: -f6)}"
    if [[ -z "${user_home}" ]]; then
        log_error "Unable to determine home for ${PODMAN_USER}"
        exit 1
    fi
    systemd_dir="${user_home}/.config/containers/systemd"
    target="${systemd_dir}/uptime-kuma.container"
    input="${target}"
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${user_home}/.config ${user_home}/.config/containers ${systemd_dir}"
    if [[ ! -f "${input}" ]]; then
        input="${TEMPLATES_DIR}/containers/uptime-kuma.container"
    fi

    tmp_out=$(mktemp)
    local in_container=0 saw_publish=0 saw_volume=0 saw_autoupdate=0 saw_image=0
    local in_install=0 saw_install=0 saw_install_default_target=0

    while IFS= read -r line || [[ -n "${line}" ]]; do
        if [[ "${line}" =~ ^\[.*\] ]]; then
            if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
                echo "WantedBy=default.target" >>"${tmp_out}"
                saw_install_default_target=1
            fi
            if [[ ${in_container} -eq 1 ]]; then
                if [[ ${saw_image} -eq 0 ]]; then
                    echo "Image=docker.io/louislam/uptime-kuma:2" >>"${tmp_out}"
                fi
                if [[ ${saw_publish} -eq 0 ]]; then
                    echo "PublishPort=3001:3001" >>"${tmp_out}"
                fi
                if [[ ${saw_volume} -eq 0 ]]; then
                    echo "Volume=/home/${PODMAN_USER}/.local/share/uptime-kuma:/app/data:Z" >>"${tmp_out}"
                fi
                if [[ ${saw_autoupdate} -eq 0 ]]; then
                    echo "AutoUpdate=registry" >>"${tmp_out}"
                fi
            fi
            in_container=0
            in_install=0
        fi

        if [[ "${line}" =~ ^\[Install\]$ ]]; then
            in_install=1
            saw_install=1
        fi

        if [[ ${in_container} -eq 1 ]]; then
            if [[ "${line}" =~ ^Image= ]]; then
                line="Image=docker.io/louislam/uptime-kuma:2"
                saw_image=1
            fi
            if [[ "${line}" =~ ^PublishPort= ]]; then
                line="PublishPort=3001:3001"
                saw_publish=1
            fi
            if [[ "${line}" =~ ^Volume= ]]; then
                line="Volume=/home/${PODMAN_USER}/.local/share/uptime-kuma:/app/data:Z"
                saw_volume=1
            fi
            if [[ "${line}" =~ ^AutoUpdate= ]]; then
                line="AutoUpdate=registry"
                saw_autoupdate=1
            fi
        fi

        if [[ ${in_install} -eq 1 && "${line}" =~ ^WantedBy= ]]; then
            if [[ "${line#WantedBy=}" == *"default.target"* ]]; then
                saw_install_default_target=1
            fi
        fi

        echo "${line}" >>"${tmp_out}"

        if [[ "${line}" == "[Container]" ]]; then
            in_container=1
            saw_publish=0
            saw_volume=0
            saw_autoupdate=0
            saw_image=0
        fi
    done < "${input}"

    if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    if [[ ${in_container} -eq 1 ]]; then
        if [[ ${saw_image} -eq 0 ]]; then
            echo "Image=docker.io/louislam/uptime-kuma:2" >>"${tmp_out}"
        fi
        if [[ ${saw_publish} -eq 0 ]]; then
            echo "PublishPort=3001:3001" >>"${tmp_out}"
        fi
        if [[ ${saw_volume} -eq 0 ]]; then
            echo "Volume=/home/${PODMAN_USER}/.local/share/uptime-kuma:/app/data:Z" >>"${tmp_out}"
        fi
        if [[ ${saw_autoupdate} -eq 0 ]]; then
            echo "AutoUpdate=registry" >>"${tmp_out}"
        fi
    fi

    if [[ ${saw_install} -eq 0 ]]; then
        echo >>"${tmp_out}"
        echo "[Install]" >>"${tmp_out}"
        echo "WantedBy=default.target" >>"${tmp_out}"
    elif [[ ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_out}"
    run_cmd "chown ${PODMAN_USER}:${PODMAN_USER} ${target}"
    run_cmd "chmod 0644 ${target}"
}

verify_quadlet_status() {
    local service="$1"
    ensure_podmin_user_manager
    if podmin_systemctl status "${service}" --no-pager; then
        return 0
    fi
    log_warn "Status check failed for ${service}; inspecting generated units"
    run_cmd "systemctl --user --machine=${PODMAN_USER}@.host list-unit-files --no-pager | grep -E 'nginx-proxy-manager|gotify' || true"
    run_cmd "ls -la /run/user/${PODMAN_UID}/systemd/generator/ | grep -E 'nginx-proxy-manager|gotify' || true"
}

configure_rootless_quadlets() {
    ensure_npm_quadlet
    ensure_gotify_quadlet
    ensure_uptime_kuma_quadlet
    if ! ensure_quadlet_generator; then
        return
    fi
    ensure_podmin_user_manager
    if ! podmin_systemctl daemon-reload; then
        log_warn "Failed to reload user systemd daemon for ${PODMAN_USER}; rootless services may not be active"
    fi
    if ! podmin_systemctl start nginx-proxy-manager.service; then
        log_warn "Failed to start nginx-proxy-manager.service for ${PODMAN_USER}; rootless services may not be active"
    else
        verify_quadlet_status nginx-proxy-manager.service
    fi
    if ! podmin_systemctl start gotify.service; then
        log_warn "Failed to start gotify.service for ${PODMAN_USER}; rootless services may not be active"
    else
        verify_quadlet_status gotify.service
    fi
    if ! podmin_systemctl start uptime-kuma.service; then
        log_warn "Failed to start uptime-kuma.service for ${PODMAN_USER}; rootless services may not be active"
    else
        verify_quadlet_status uptime-kuma.service
    fi
}

configure_socket_proxyd() {
    local http_socket=/etc/systemd/system/archarden-http.socket
    local http_service=/etc/systemd/system/archarden-http.service
    local https_socket=/etc/systemd/system/archarden-https.socket
    local https_service=/etc/systemd/system/archarden-https.service

    backup_file "${http_socket}"
    backup_file "${http_service}"
    backup_file "${https_socket}"
    backup_file "${https_service}"

    write_file_atomic "${http_socket}" <<'EOT'
[Socket]
ListenStream=80
Accept=no

[Install]
WantedBy=sockets.target
EOT

    write_file_atomic "${http_service}" <<'EOT'
[Unit]
Requires=archarden-http.socket

[Service]
ExecStart=/usr/lib/systemd/systemd-socket-proxyd 127.0.0.1:8080
StandardInput=socket
EOT

    write_file_atomic "${https_socket}" <<'EOT'
[Socket]
ListenStream=443
Accept=no

[Install]
WantedBy=sockets.target
EOT

    write_file_atomic "${https_service}" <<'EOT'
[Unit]
Requires=archarden-https.socket

[Service]
ExecStart=/usr/lib/systemd/systemd-socket-proxyd 127.0.0.1:8443
StandardInput=socket
EOT

    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable --now archarden-http.socket archarden-https.socket"
}

ensure_podmin_podman_socket() {
    ensure_podmin_user_manager
    podmin_systemctl enable --now podman.socket
}

ensure_podman_api_group() {
    if getent group "${PODMAN_API_GROUP}" >/dev/null 2>&1; then
        :
    else
        run_cmd "groupadd -r ${PODMAN_API_GROUP}"
        log_info "Created system group ${PODMAN_API_GROUP} for Podman API access"
    fi
    if [[ -n "${USER_NAME}" ]]; then
        ensure_user_in_group "${USER_NAME}" "${PODMAN_API_GROUP}"
    fi
}

configure_podman_api_proxy() {
    ensure_podmin_podman_socket
    ensure_podman_api_group

    local proxy_socket=/etc/systemd/system/podmin-podman.socket
    local proxy_service=/etc/systemd/system/podmin-podman.service
    local podman_socket="unix:/run/user/${PODMAN_UID}/podman/podman.sock"

    backup_file "${proxy_socket}"
    backup_file "${proxy_service}"

    write_file_atomic "${proxy_socket}" <<EOT
[Unit]
Description=Proxy socket to ${PODMAN_USER} Podman API

[Socket]
ListenStream=/run/podmin-podman.sock
SocketMode=0660
SocketUser=root
SocketGroup=${PODMAN_API_GROUP}
RemoveOnStop=yes

[Install]
WantedBy=sockets.target
EOT

    write_file_atomic "${proxy_service}" <<EOT
[Unit]
Description=Proxy to ${PODMAN_USER} Podman API
Requires=podmin-podman.socket
After=podmin-podman.socket

[Service]
ExecStart=/usr/lib/systemd/systemd-socket-proxyd ${podman_socket}
User=root
Group=root
StandardInput=socket

[Install]
WantedBy=multi-user.target
EOT

    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable --now podmin-podman.socket"
}

configure_gotify_notifications() {
    local env_file=/etc/archarden/notify-gotify.env
    local lib_dir=/usr/local/lib/archarden
    local os_report_service=/etc/systemd/system/archarden-os-report.service
    local os_report_timer=/etc/systemd/system/archarden-os-report.timer
    local container_scan_service=/etc/systemd/system/archarden-container-scan.service
    local container_scan_timer=/etc/systemd/system/archarden-container-scan.timer

    run_cmd "install -d -m 0700 /etc/archarden"
    run_cmd "install -d -m 0750 ${lib_dir}"

    if [[ ! -f "${env_file}" ]]; then
        write_file_atomic "${env_file}" <<'EOT'
# Gotify endpoint and access token (leave blank to disable notifications)
GOTIFY_URL=
GOTIFY_TOKEN=
# Optional priority (default 5)
GOTIFY_PRIORITY=5
EOT
    fi
    run_cmd "chmod 0600 ${env_file}"
    run_cmd "chown root:root ${env_file}"

    write_file_atomic "${lib_dir}/gotify_send.sh" <<'EOT'
#!/usr/bin/env bash
set -euo pipefail

env_file="/etc/archarden/notify-gotify.env"
if [[ -f "${env_file}" ]]; then
  # shellcheck disable=SC1090
  source "${env_file}"
fi

if [[ -z "${GOTIFY_URL:-}" || -z "${GOTIFY_TOKEN:-}" ]]; then
  echo "Gotify not configured; skipping notification" >&2
  exit 0
fi

if [[ $# -lt 2 ]]; then
  echo "Usage: ${0} <title> <message>" >&2
  exit 1
fi

title="$1"
message="$2"
priority="${GOTIFY_PRIORITY:-5}"

if [[ ${#message} -gt 3500 ]]; then
  message="${message:0:3500}"
fi

if ! curl -fsS -X POST "${GOTIFY_URL%/}/message?token=${GOTIFY_TOKEN}" \
  -F "title=${title}" \
  -F "message=${message}" \
  -F "priority=${priority}" >/dev/null; then
  echo "Failed to send Gotify notification" >&2
fi
EOT
    run_cmd "chmod 0750 ${lib_dir}/gotify_send.sh"
    run_cmd "chown root:root ${lib_dir}/gotify_send.sh"

    write_file_atomic "${lib_dir}/os_update_report.sh" <<'EOT'
#!/usr/bin/env bash
set -euo pipefail

notify_bin="/usr/local/lib/archarden/gotify_send.sh"
updates_output=""
audit_output=""

if command -v checkupdates >/dev/null 2>&1; then
  updates_output=$(checkupdates 2>/dev/null || true)
else
  echo "checkupdates not available; skipping pacman update check" >&2
fi

if command -v arch-audit >/dev/null 2>&1; then
  audit_output=$(arch-audit 2>/dev/null || true)
else
  echo "arch-audit not available; skipping advisory check" >&2
fi

if [[ -z "${updates_output}" && -z "${audit_output}" ]]; then
  exit 0
fi

message="PACMAN UPDATES"
if [[ -n "${updates_output}" ]]; then
  message+="
${updates_output}"
else
  message+="
None"
fi

message+="

ARCH-AUDIT"
if [[ -n "${audit_output}" ]]; then
  message+="
${audit_output}"
else
  message+="
None"
fi

"${notify_bin}" "Arch updates and advisories" "${message}"
EOT
    run_cmd "chmod 0750 ${lib_dir}/os_update_report.sh"
    run_cmd "chown root:root ${lib_dir}/os_update_report.sh"

    write_file_atomic "${lib_dir}/container_update_scan.sh" <<'EOT'
#!/usr/bin/env bash
set -euo pipefail

notify_bin="/usr/local/lib/archarden/gotify_send.sh"
auto_update_output=""
ps_output=""
updates_rc=0

if command -v podman >/dev/null 2>&1; then
  auto_update_output=$(runuser -u podmin -- podman auto-update --dry-run 2>&1) || updates_rc=$?
  ps_output=$(runuser -u podmin -- podman ps --format '{{.Names}}\t{{.Image}}\t{{.Status}}' 2>&1 || true)
else
  updates_rc=1
  auto_update_output="podman not available"
fi

trimmed_updates=$(echo "${auto_update_output}" | sed '/^[[:space:]]*$/d')

if [[ ${updates_rc} -ne 0 ]]; then
  message="Podman auto-update --dry-run failed:
${auto_update_output}"
  if [[ -n "${ps_output}" ]]; then
    message+="

Running containers:
${ps_output}"
  fi
  "${notify_bin}" "Container update scan error" "${message}"
  exit 0
fi

if [[ -z "${trimmed_updates}" ]] || [[ "${trimmed_updates,,}" =~ no[[:space:]]+.*update ]]; then
  exit 0
fi

message="Podman auto-update --dry-run reported updates:
${trimmed_updates}"

if [[ -n "${ps_output}" ]]; then
  message+="

Running containers:
${ps_output}"
fi

"${notify_bin}" "Container updates available" "${message}"
EOT
    run_cmd "chmod 0750 ${lib_dir}/container_update_scan.sh"
    run_cmd "chown root:root ${lib_dir}/container_update_scan.sh"

    write_file_atomic "${os_report_service}" <<'EOT'
[Unit]
Description=Archarden daily OS update and advisory report
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/lib/archarden/os_update_report.sh
EOT

    write_file_atomic "${os_report_timer}" <<'EOT'
[Unit]
Description=Run archarden OS update report daily

[Timer]
OnCalendar=*-*-* 03:15:00
Persistent=true

[Install]
WantedBy=timers.target
EOT

    write_file_atomic "${container_scan_service}" <<'EOT'
[Unit]
Description=Archarden weekly container update scan
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/lib/archarden/container_update_scan.sh
EOT

    write_file_atomic "${container_scan_timer}" <<'EOT'
[Unit]
Description=Run archarden container update scan weekly

[Timer]
OnCalendar=Sun 04:20:00
Persistent=true

[Install]
WantedBy=timers.target
EOT

    run_cmd "chmod 0644 ${os_report_service} ${os_report_timer} ${container_scan_service} ${container_scan_timer}"
    run_cmd "chown root:root ${os_report_service} ${os_report_timer} ${container_scan_service} ${container_scan_timer}"
    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable --now archarden-os-report.timer"
    run_cmd "systemctl enable --now archarden-container-scan.timer"
}

configure_sshd() {
    mkdir -p "${SSHD_CONFIG_DIR}"
    run_cmd "ssh-keygen -A"
    backup_file "${SSHD_HARDENING_DROPIN}"
    backup_file "${SSHD_CRYPTO_DROPIN}"
    sed "s/__SSH_PORT__/${SSH_PORT}/g" "${CONFIG_DIR}/sshd_hardening.conf" | write_file_atomic "${SSHD_HARDENING_DROPIN}"
    write_file_atomic "${SSHD_CRYPTO_DROPIN}" < "${CONFIG_DIR}/sshd_crypto_hardening.conf"
    if [ "${DRY_RUN}" -eq 0 ]; then
        if ! sshd -t; then
            log_error "sshd configuration failed validation"
            restore_sshd_dropins
            exit 1
        fi
    else
        log_info "[DRY-RUN] Skipping sshd validation"
    fi
}

configure_sysctl() {
    backup_file /etc/sysctl.d/99-hardening.conf
    write_file_atomic /etc/sysctl.d/99-hardening.conf < "${CONFIG_DIR}/sysctl_hardening.conf"
}

configure_vm_tuning_sysctl() {
    local dest=/etc/sysctl.d/99-vm-tuning.conf
    backup_file "${dest}"
    write_file_atomic "${dest}" < "${CONFIG_DIR}/vm-tuning.conf"
}

apply_sysctl_settings() {
    run_cmd "sysctl --system"
}

configure_tmp_mount() {
    backup_file /etc/systemd/system/tmp.mount
    write_file_atomic /etc/systemd/system/tmp.mount < "${CONFIG_DIR}/tmp.mount"
    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable --now tmp.mount"
}

configure_zram() {
    local dest=/etc/systemd/zram-generator.conf
    backup_file "${dest}"
    write_file_atomic "${dest}" < "${CONFIG_DIR}/zram-generator.conf"
    run_cmd "systemctl daemon-reload"
    if ! run_cmd "systemctl restart systemd-zram-setup@zram0.service"; then
        log_warn "systemd-zram-setup@zram0.service not available; ensure zram-generator is installed and units exist."
    fi
}

discover_public_ipv4() {
    local ip
    ip=$(ip -4 route get 1.1.1.1 2>/dev/null | awk '/src/ {for (i=1; i<=NF; i++) if ($i=="src") print $(i+1)}' | head -n1)
    if [[ -z "${ip}" ]]; then
        ip=$(ip -4 addr show scope global 2>/dev/null | awk '/inet / {sub("/.*","",$2); print $2}' | head -n1)
    fi
    echo "${ip}"
}

load_wireguard_config() {
    local cfg="${CONFIG_DIR}/wireguard.conf" entry name ip
    if [[ ! -f "${cfg}" ]]; then
        log_error "WireGuard config file not found at ${cfg}"
        exit 1
    fi

    WG_PEERS=()
    # shellcheck disable=SC1090
    source "${cfg}"

    if [[ -z "${WG_INTERFACE_ADDRESS:-}" || -z "${WG_LISTEN_PORT:-}" || -z "${WG_DNS:-}" ]]; then
        log_error "WG_INTERFACE_ADDRESS, WG_LISTEN_PORT, and WG_DNS must be set in ${cfg}"
        exit 1
    fi

    WIREGUARD_SERVER_IP="${WG_INTERFACE_ADDRESS%%/*}"
    WIREGUARD_SERVER_ALLOWED_IP="${WIREGUARD_SERVER_IP}/32"
    WIREGUARD_PEER_NAMES=()
    WIREGUARD_PEER_IPS=()

    if [[ ${#WG_PEERS[@]} -eq 0 ]]; then
        log_error "WG_PEERS must include at least one entry in ${cfg} (format: name:address)"
        exit 1
    fi

    for entry in "${WG_PEERS[@]}"; do
        IFS=":" read -r name ip <<<"${entry}"
        if [[ -z "${name}" || -z "${ip}" ]]; then
            log_error "Invalid WireGuard peer entry '${entry}' in ${cfg}; expected name:address"
            exit 1
        fi
        WIREGUARD_PEER_NAMES+=("${name}")
        WIREGUARD_PEER_IPS+=("${ip}")
    done

    WIREGUARD_CONFIG_LOADED=1
}

ensure_wireguard_config_loaded() {
    if [[ ${WIREGUARD_CONFIG_LOADED} -eq 0 ]]; then
        load_wireguard_config
    fi
}

ensure_wireguard_keypair() {
    local name="$1" key_path="$2" pub_path="$3"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would ensure WireGuard keypair for ${name} at ${key_path}"
        return
    fi
    run_cmd "install -d -m 0700 /etc/wireguard/keys"
    if [[ ! -f "${key_path}" ]]; then
        run_cmd "umask 077 && wg genkey > ${key_path}"
    fi
    if [[ ! -f "${pub_path}" ]]; then
        run_cmd "umask 077 && wg pubkey < ${key_path} > ${pub_path}"
    fi
    run_cmd "chmod 0600 ${key_path} ${pub_path}"
}

read_wireguard_key() {
    local path="$1" fallback="$2"
    if [[ -f "${path}" ]]; then
        tr -d '\n' < "${path}"
    else
        echo "${fallback}"
    fi
}

append_wireguard_peer() {
    local tmp_file="$1" name="$2" pub_key="$3" allowed_ip="$4"
    if grep -q "PublicKey = ${pub_key}" "${tmp_file}"; then
        return
    fi
    {
        echo
        echo "[Peer]"
        echo "# ${name}"
        echo "PublicKey = ${pub_key}"
        echo "AllowedIPs = ${allowed_ip}"
        echo "PersistentKeepalive = 25"
    } >> "${tmp_file}"
}

ensure_wireguard_config() {
    ensure_wireguard_config_loaded
    local server_priv server_pub tmp wg_conf=/etc/wireguard/wg0.conf
    local -a peer_pub_keys=()
    if [[ ${DRY_RUN} -eq 1 ]]; then
        server_priv="DRY_RUN_SERVER_KEY"
        server_pub="DRY_RUN_SERVER_PUB"
        for name in "${WIREGUARD_PEER_NAMES[@]}"; do
            peer_pub_keys+=("DRY_RUN_${name^^}_PUB")
        done
    else
        ensure_wireguard_keypair "server" /etc/wireguard/keys/server.key /etc/wireguard/keys/server.pub
        server_priv=$(read_wireguard_key /etc/wireguard/keys/server.key "")
        server_pub=$(read_wireguard_key /etc/wireguard/keys/server.pub "")
        local idx=0
        for name in "${WIREGUARD_PEER_NAMES[@]}"; do
            ensure_wireguard_keypair "${name}" "/etc/wireguard/keys/${name}.key" "/etc/wireguard/keys/${name}.pub"
            peer_pub_keys[idx]=$(read_wireguard_key "/etc/wireguard/keys/${name}.pub" "")
            ((idx += 1))
        done
        run_cmd "install -d -m 0700 /root/wireguard/clients"
    fi

    tmp=$(mktemp)
    if [[ ! -f "${wg_conf}" ]]; then
        cat <<EOT > "${tmp}"
[Interface]
Address = ${WG_INTERFACE_ADDRESS}
ListenPort = ${WG_LISTEN_PORT}
PrivateKey = ${server_priv}
EOT
    else
        local in_interface=0 saw_address=0 saw_listen=0 saw_private=0
        while IFS= read -r line || [[ -n "${line}" ]]; do
            if [[ "${line}" =~ ^\[.*\] ]]; then
                if [[ ${in_interface} -eq 1 ]]; then
                    if [[ ${saw_address} -eq 0 ]]; then
                        echo "Address = ${WG_INTERFACE_ADDRESS}" >> "${tmp}"
                    fi
                    if [[ ${saw_listen} -eq 0 ]]; then
                        echo "ListenPort = ${WG_LISTEN_PORT}" >> "${tmp}"
                    fi
                    if [[ ${saw_private} -eq 0 ]]; then
                        echo "PrivateKey = ${server_priv}" >> "${tmp}"
                    fi
                fi
                in_interface=0
            fi

            if [[ "${line}" == "[Interface]" ]]; then
                in_interface=1
                saw_address=0
                saw_listen=0
                saw_private=0
            elif [[ ${in_interface} -eq 1 ]]; then
                if [[ "${line}" =~ ^Address[[:space:]]*= ]]; then
                    line="Address = ${WG_INTERFACE_ADDRESS}"
                    saw_address=1
                elif [[ "${line}" =~ ^ListenPort[[:space:]]*= ]]; then
                    line="ListenPort = ${WG_LISTEN_PORT}"
                    saw_listen=1
                elif [[ "${line}" =~ ^PrivateKey[[:space:]]*= ]]; then
                    line="PrivateKey = ${server_priv}"
                    saw_private=1
                fi
            fi

            echo "${line}" >> "${tmp}"
        done < "${wg_conf}"

        if [[ ${in_interface} -eq 1 ]]; then
            if [[ ${saw_address} -eq 0 ]]; then
                echo "Address = ${WG_INTERFACE_ADDRESS}" >> "${tmp}"
            fi
            if [[ ${saw_listen} -eq 0 ]]; then
                echo "ListenPort = ${WG_LISTEN_PORT}" >> "${tmp}"
            fi
            if [[ ${saw_private} -eq 0 ]]; then
                echo "PrivateKey = ${server_priv}" >> "${tmp}"
            fi
        fi
    fi

    local i
    for i in "${!WIREGUARD_PEER_NAMES[@]}"; do
        append_wireguard_peer "${tmp}" "${WIREGUARD_PEER_NAMES[i]}" "${peer_pub_keys[i]}" "${WIREGUARD_PEER_IPS[i]}"
    done

    write_file_atomic "${wg_conf}" < "${tmp}"
    rm -f "${tmp}"
    if [[ ${DRY_RUN} -eq 0 ]]; then
        run_cmd "chmod 0600 ${wg_conf}"
        run_cmd "chown root:root ${wg_conf}"
    fi
}

ensure_wireguard_client_config() {
    local name="${1-}" ip_addr="${2-}" server_pub="${3-}" endpoint="${4-}"
    if [[ -z "${name}" || -z "${ip_addr}" || -z "${server_pub}" || -z "${endpoint}" ]]; then
        log_error "ensure_wireguard_client_config requires name, ip_addr, server_pub, and endpoint"
        exit 1
    fi

    local key_path="/etc/wireguard/keys/${name}.key" pub_path="/etc/wireguard/keys/${name}.pub" client_conf="/root/wireguard/clients/${name}.conf"
    local priv_key pub_key tmp
    if [[ ${DRY_RUN} -eq 1 ]]; then
        priv_key="DRY_RUN_${name^^}_KEY"
        pub_key="DRY_RUN_${name^^}_PUB"
    else
        ensure_wireguard_keypair "${name}" "${key_path}" "${pub_path}"
        priv_key=$(read_wireguard_key "${key_path}" "")
        pub_key=$(read_wireguard_key "${pub_path}" "")
    fi

    tmp=$(mktemp)
    cat <<EOT > "${tmp}"
[Interface]
Address = ${ip_addr}
PrivateKey = ${priv_key}
DNS = ${WG_DNS}

[Peer]
PublicKey = ${server_pub}
Endpoint = ${endpoint}
AllowedIPs = ${WIREGUARD_SERVER_ALLOWED_IP}
PersistentKeepalive = 25
EOT

    write_file_atomic "${client_conf}" < "${tmp}"
    rm -f "${tmp}"
    if [[ ${DRY_RUN} -eq 0 ]]; then
        run_cmd "chmod 0600 ${client_conf}"
        run_cmd "chown root:root ${client_conf}"
    fi
}

configure_wireguard() {
    ensure_wireguard_config_loaded
    local server_pub endpoint_ip endpoint_host="YOUR_SERVER_IP" endpoint

    ensure_wireguard_config
    server_pub=$(read_wireguard_key /etc/wireguard/keys/server.pub "DRY_RUN_SERVER_PUB")
    endpoint_ip=$(discover_public_ipv4)
    if [[ -n "${endpoint_ip}" ]]; then
        endpoint_host="${endpoint_ip}"
    else
        log_warn "Could not detect public IPv4 address; using placeholder in WireGuard client configs"
    fi
    endpoint="${endpoint_host}:${WG_LISTEN_PORT}"

    local i
    for i in "${!WIREGUARD_PEER_NAMES[@]}"; do
        ensure_wireguard_client_config "${WIREGUARD_PEER_NAMES[i]}" "${WIREGUARD_PEER_IPS[i]}" "${server_pub}" "${endpoint}"
    done

    if [[ ${DRY_RUN} -eq 0 ]]; then
        run_cmd "systemctl enable --now wg-quick@wg0.service"
    else
        log_info "[DRY-RUN] Would enable and start wg-quick@wg0.service"
    fi
    run_status_capture "wg show wg0" wg show wg0
    run_status_capture "systemctl is-active wg-quick@wg0" systemctl is-active wg-quick@wg0.service
    log_info "WireGuard client configs available under /root/wireguard/clients"
}

configure_ufw() {
    if [[ ${ENABLE_FIREWALL} -eq 0 ]]; then
        log_warn "Firewall configuration disabled by flag"
        return
    fi
    ensure_wireguard_config_loaded
    ensure_firewall_backend

    if ! command -v ufw >/dev/null 2>&1; then
        log_error "ufw command not found; install the ufw package."
        exit 1
    fi

    backup_file /etc/default/ufw
    run_cmd "sed -i 's/^IPV6=.*/IPV6=yes/' /etc/default/ufw || echo 'IPV6=yes' >> /etc/default/ufw"
    run_cmd "ufw --force reset"
    run_cmd "ufw default deny incoming"
    run_cmd "ufw default allow outgoing"

    if ufw --version 2>/dev/null | grep -qi nftables; then
        log_info "UFW reports nftables backend"
    else
        log_warn "UFW backend is not reporting nftables; ensure iptables-nft is the active alternative."
    fi

    if [[ -n "${RESTRICT_SSH_CIDR}" ]]; then
        run_cmd "ufw allow from ${RESTRICT_SSH_CIDR} to any port ${SSH_PORT} proto tcp"
    else
        run_cmd "ufw limit ${SSH_PORT}/tcp"
    fi

    if ss -tulpn 2>/dev/null | grep -q ':22'; then
        run_cmd "ufw allow 22/tcp"
    fi
    if [[ ${KEEP_SSH_22} -eq 1 ]]; then
        run_cmd "ufw allow 22/tcp"
    fi

    local allowlist_entries=()
    while IFS= read -r port; do
        allowlist_entries+=("${port}")
    done < <(read_packages_from_file "${CONFIG_DIR}/firewall_allow.list" 1)

    if [[ ${#allowlist_entries[@]} -eq 0 ]]; then
        log_warn "No firewall allowlist entries defined; skipping port allows"
    else
        for port in "${allowlist_entries[@]}"; do
            run_cmd "ufw allow ${port}"
        done
    fi

    run_cmd "ufw allow ${WG_LISTEN_PORT}/udp comment 'WireGuard'"
    run_cmd "ufw allow in on wg0 to any port 81 proto tcp comment 'NPM Admin (VPN)'"
    run_cmd "ufw allow in on wg0 to any port 3001 proto tcp comment 'Uptime Kuma (VPN)'"

    if [[ ${SKIP_FIREWALL_ENABLE} -eq 1 ]]; then
        log_warn "Skipping firewall enable as requested"
        return
    fi

    run_cmd "ufw --force enable"
    if command -v systemctl >/dev/null 2>&1; then
        run_cmd "systemctl enable --now ufw"
    else
        log_warn "systemctl not found; ensure ufw starts on boot"
    fi
    if [[ ${KEEP_SSH_22} -eq 0 ]]; then
        if [ "${DRY_RUN}" -eq 0 ]; then
            ufw delete allow 22/tcp >/dev/null 2>&1 || true
        else
            log_info "[DRY-RUN] Would remove legacy SSH port 22 rule"
        fi
    fi
    run_cmd "ufw reload"
}

ensure_admin_sudoers() {
    local sudoers_file=/etc/sudoers.d/90-archarden-ssh-user tmp
    tmp=$(mktemp)
    printf "%s ALL=(ALL) NOPASSWD: ALL\n" "${USER_NAME}" > "${tmp}"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would install sudoers entry at ${sudoers_file} for ${USER_NAME}"
        rm -f "${tmp}"
        return
    fi
    backup_file "${sudoers_file}"
    install -D -m 0440 "${tmp}" "${sudoers_file}"
    chown root:root "${sudoers_file}"
    rm -f "${tmp}"
}

create_admin_user() {
    if [[ -z "${USER_NAME}" ]]; then
        return
    fi
    if id -u "${USER_NAME}" >/dev/null 2>&1; then
        log_info "User ${USER_NAME} already exists"
    else
        run_cmd "useradd -m -G wheel,ssh -s /bin/bash ${USER_NAME}"
        log_info "Created user ${USER_NAME} and added to wheel,ssh"
    fi
    ensure_user_in_group "${USER_NAME}" wheel
    ensure_user_in_group "${USER_NAME}" ssh
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would lock password for ${USER_NAME}"
    else
        run_cmd "passwd -l ${USER_NAME}"
    fi
    USER_HOME=$(getent passwd "${USER_NAME}" | cut -d: -f6)
    if [[ -z "${USER_HOME}" ]]; then
        log_error "Unable to determine home for ${USER_NAME}"
        exit 1
    fi
    if [[ -n "${PUBKEY_FILE}" ]]; then
        PUBKEY_VALUE=$(cat "${PUBKEY_FILE}")
    fi
    if [[ -n "${PUBKEY_VALUE}" ]]; then
        local ssh_dir="${USER_HOME}/.ssh"
        run_cmd "install -d -m 700 -o ${USER_NAME} -g ${USER_NAME} ${ssh_dir}"
        local auth_keys="${ssh_dir}/authorized_keys"
        if [ "${DRY_RUN}" -eq 0 ]; then
            if [ ! -f "${auth_keys}" ]; then
                touch "${auth_keys}"
                chown "${USER_NAME}:${USER_NAME}" "${auth_keys}"
                chmod 600 "${auth_keys}"
            fi
            if ! grep -qxF "${PUBKEY_VALUE}" "${auth_keys}"; then
                echo "${PUBKEY_VALUE}" >>"${auth_keys}"
            fi
        else
            log_info "[DRY-RUN] Would add key for ${USER_NAME}"
        fi
    else
        log_warn "No public key provided for ${USER_NAME}; ensure key-based auth manually."
    fi

    ensure_admin_sudoers
}

ensure_podmin_user() {
    local expected_home="/home/${PODMAN_USER}" current_home current_shell
    if id -u "${PODMAN_USER}" >/dev/null 2>&1; then
        log_info "Podman runtime user ${PODMAN_USER} already exists"
        current_home=$(getent passwd "${PODMAN_USER}" | cut -d: -f6)
        current_shell=$(getent passwd "${PODMAN_USER}" | cut -d: -f7)
        if [[ "${current_home}" != "${expected_home}" ]]; then
            run_cmd "usermod -d ${expected_home} -m ${PODMAN_USER}"
        fi
        if [[ "${current_shell}" != "/usr/bin/nologin" ]]; then
            run_cmd "usermod -s /usr/bin/nologin ${PODMAN_USER}"
        fi
    else
        run_cmd "useradd -m -d ${expected_home} -s /usr/bin/nologin ${PODMAN_USER}"
        log_info "Created podman runtime user ${PODMAN_USER} with nologin shell"
    fi
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would lock password for ${PODMAN_USER}"
    else
        run_cmd "passwd -l ${PODMAN_USER}"
    fi
    if getent group ssh >/dev/null 2>&1; then
        run_cmd "gpasswd -d ${PODMAN_USER} ssh >/dev/null 2>&1 || true"
    fi
    if getent group wheel >/dev/null 2>&1; then
        run_cmd "gpasswd -d ${PODMAN_USER} wheel >/dev/null 2>&1 || true"
    fi
    run_cmd "install -d -m 0750 -o ${PODMAN_USER} -g ${PODMAN_USER} ${expected_home}"
    PODMAN_HOME=$(getent passwd "${PODMAN_USER}" | cut -d: -f6)
    if [[ -z "${PODMAN_HOME}" ]]; then
        if [[ ${DRY_RUN} -eq 1 ]]; then
            PODMAN_HOME="${expected_home}"
        else
            log_error "Unable to determine home for ${PODMAN_USER}"
            exit 1
        fi
    fi
    if ! loginctl enable-linger "${PODMAN_USER}" >/dev/null 2>&1; then
        log_warn "Could not enable linger for ${PODMAN_USER}; rootless services may not restart after reboot"
    fi
}

enable_timesync() {
    run_cmd "systemctl enable --now systemd-timesyncd.service"
}

ensure_firewall_backend() {
    if ! command -v nft >/dev/null 2>&1; then
        log_error "nft command not found; firewall configuration cannot continue."
        exit 1
    fi

    if nft list tables >/dev/null 2>&1; then
        return
    fi

    log_warn "nftables backend unavailable; attempting to load firewall kernel modules"
    local modules=()
    while IFS= read -r mod; do
        modules+=("${mod}")
    done < <(read_packages_from_file "${CONFIG_DIR}/firewall_modules.list")
    for mod in "${modules[@]}"; do
        if modinfo "${mod}" >/dev/null 2>&1; then
            run_cmd "modprobe ${mod} || true"
        fi
    done

    if nft list tables >/dev/null 2>&1; then
        log_info "Firewall kernel modules loaded successfully"
        return
    fi

    log_error "nftables backend still unavailable. Ensure firewall kernel modules are present or rerun with --skip-firewall-enable or --disable-firewall."
    exit 1
}

ensure_grub_defaults_saved() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would ensure /etc/default/grub has GRUB_DEFAULT=saved and GRUB_SAVEDEFAULT=true"
        return
    fi
    if [[ ! -f /etc/default/grub ]]; then
        log_error "/etc/default/grub not found; cannot set GRUB_DEFAULT/GRUB_SAVEDEFAULT."
        exit 1
    fi
    backup_file /etc/default/grub
    if grep -q '^GRUB_DEFAULT=' /etc/default/grub; then
        run_cmd "sed -i 's/^GRUB_DEFAULT=.*/GRUB_DEFAULT=saved/' /etc/default/grub"
    else
        run_cmd "echo 'GRUB_DEFAULT=saved' >> /etc/default/grub"
    fi
    if grep -q '^GRUB_SAVEDEFAULT=' /etc/default/grub; then
        run_cmd "sed -i 's/^GRUB_SAVEDEFAULT=.*/GRUB_SAVEDEFAULT=true/' /etc/default/grub"
    else
        run_cmd "echo 'GRUB_SAVEDEFAULT=true' >> /etc/default/grub"
    fi
}

ensure_lts_kernel_and_reboot_gate() {
    if ! command -v grub-mkconfig >/dev/null 2>&1; then
        log_error "grub-mkconfig not found; unable to set linux-lts as default."
        exit 1
    fi
    if ! command -v grub-set-default >/dev/null 2>&1; then
        log_error "grub-set-default not found; unable to set linux-lts as default."
        exit 1
    fi
    if ! command -v grub-editenv >/dev/null 2>&1; then
        log_error "grub-editenv not found; unable to verify default boot entry."
        exit 1
    fi

    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would fully upgrade, install linux-lts, regenerate GRUB, set default to '${GRUB_LTS_ENTRY}', verify grub-editenv, and require reboot before hardening."
        return
    fi

    local current_kernel saved_entry
    current_kernel=$(uname -r)
    saved_entry=$(grub-editenv list 2>/dev/null | awk -F= '/^saved_entry=/{print $2}' || true)

    if [[ "${current_kernel}" == *-lts ]] && [[ "${saved_entry}" == "${GRUB_LTS_ENTRY}" ]]; then
        log_info "System already booted into linux-lts with GRUB default set; continuing with hardening."
        return
    fi

    log_info "Pre-hardening: updating system and preparing linux-lts default boot entry."
    if ! {
        run_cmd "pacman -Syu --noconfirm"
        run_cmd "pacman -S --needed --noconfirm linux-lts"
        ensure_grub_defaults_saved
        run_cmd "grub-mkconfig -o ${GRUB_CONFIG_PATH}"
        run_cmd "grub-set-default \"${GRUB_LTS_ENTRY}\""
    }; then
        log_error "$(red "linux-lts installation failed; please review ${LOG_FILE}")"
        exit 1
    fi

    saved_entry=$(grub-editenv list 2>/dev/null | awk -F= '/^saved_entry=/{print $2}' || true)
    if [[ "${saved_entry}" != "${GRUB_LTS_ENTRY}" ]]; then
        log_error "Expected GRUB saved_entry '${GRUB_LTS_ENTRY}', but grub-editenv reported '${saved_entry:-<unset>}'"
        exit 1
    fi

    record_pending_args "$@"
    write_continue_service
    local resume_cmd="${INSTALL_BIN} --resume $(cat ${PENDING_ARGS_FILE})"
    log_warn "$(yellow "Reboot required: linux-lts installed and set as default. Rebooting will auto-resume hardening via systemd.")"
    log_info "Manual resume command: ${resume_cmd}"
    log_info "$(green "LTS kernel installed. Rebooting in 5 seconds...")"
    sleep 5
    run_cmd "reboot"
}

ensure_ssh_group() {
    if getent group ssh >/dev/null 2>&1; then
        local current_gid
        current_gid=$(getent group ssh | cut -d: -f3)
        if (( current_gid < 1000 )); then
            log_info "SSH access group 'ssh' already exists as a system group (gid ${current_gid})"
            return
        fi

        local new_gid
        if ! new_gid=$(next_available_system_gid); then
            log_error "Unable to find a free system gid (<1000) to convert 'ssh' group"
            exit 1
        fi

        run_cmd "groupmod -g ${new_gid} ssh"
        log_warn "Converted existing 'ssh' group to system gid ${new_gid}"
        return
    fi

    run_cmd "groupadd -r ssh"
    log_info "Created system group 'ssh' for SSH access control"
}

ensure_user_in_group() {
    local user="$1" group="$2"
    if ! id -u "${user}" >/dev/null 2>&1; then
        if [[ ${DRY_RUN} -eq 1 ]]; then
            log_info "[DRY-RUN] Would ensure ${user} is in group ${group}"
            return
        fi
        log_error "User ${user} does not exist; cannot add to ${group}"
        exit 1
    fi
    if id -nG "${user}" | tr ' ' '\n' | grep -qx "${group}"; then
        return
    fi
    run_cmd "usermod -aG ${group} ${user}"
    log_info "Added ${user} to ${group}"
}

error_trap() {
    local exit_code=$?
    local cmd=${BASH_COMMAND}
    local src=${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}
    local line=${BASH_LINENO[0]:-0}
    log_error "Command failed with exit ${exit_code} at ${src}:${line}: ${cmd}"
    log_error "See ${LOG_FILE} for details."
    exit ${exit_code}
}
trap 'error_trap' ERR

switch_to_phase1_logging() {
    if [[ "${CURRENT_PHASE}" == "phase1" ]]; then
        return
    fi
    CURRENT_PHASE="phase1"
    LOG_FILE="${PHASE1_LOG}"
    export LOG_FILE
    log_info "==== Starting Phase 1 actions (logging to ${LOG_FILE}) ===="
}

run_as_user() {
    local user="$1"; shift
    local cmd="$*"
    local uid runtime_dir
    uid=$(id -u "${user}")
    runtime_dir="/run/user/${uid}"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] (as ${user}) ${cmd}"
        return 0
    fi
    run_cmd "install -d -m 0700 -o ${user} -g ${user} ${runtime_dir}"
    log_info "Running as ${user}: ${cmd}"
    set +e
    HOME=$(eval echo "~${user}") XDG_RUNTIME_DIR="${runtime_dir}" runuser -l "${user}" -c "${cmd}"
    local rc=$?
    set -e
    return ${rc}
}

ensure_podmin_user_manager() {
    local runtime_dir err_file err_msg
    if [[ ${ENSURED_PODMIN_MANAGER} -eq 1 ]]; then
        return 0
    fi
    if [[ -n "${PODMAN_UID}" ]]; then
        runtime_dir="/run/user/${PODMAN_UID}"
    else
        PODMAN_UID=$(id -u "${PODMAN_USER}")
        runtime_dir="/run/user/${PODMAN_UID}"
    fi
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Ensuring user manager for ${PODMAN_USER} (uid ${PODMAN_UID})"
        return 0
    fi
    if ! loginctl enable-linger "${PODMAN_USER}" >/dev/null 2>&1; then
        log_warn "Could not enable linger for ${PODMAN_USER}; rootless services may not persist across reboots"
    fi
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${runtime_dir}"
    err_file=$(mktemp)
    if ! systemctl start "user@${PODMAN_UID}.service" >/dev/null 2>"${err_file}"; then
        err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
        if [[ -n "${err_msg}" ]]; then
            log_warn "Could not start user@${PODMAN_UID}.service for ${PODMAN_USER}: ${err_msg}"
        fi
    fi
    rm -f "${err_file}"
    ENSURED_PODMIN_MANAGER=1
}

podmin_systemctl() {
    local uid runtime_dir err_file err_msg
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] (as ${PODMAN_USER}) systemctl --user --machine=${PODMAN_USER}@.host $*"
        return 0
    fi
    ensure_podmin_user_manager
    uid="${PODMAN_UID}"
    runtime_dir="/run/user/${uid}"

    err_file=$(mktemp)
    if systemctl --user --machine="${PODMAN_USER}@.host" "$@" >/dev/null 2>"${err_file}"; then
        rm -f "${err_file}"
        return 0
    fi
    err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
    rm -f "${err_file}"
    log_warn "podmin systemctl (machine) failed: ${err_msg:-unknown}; retrying with runtime dir bus"

    if [[ ! -S "${runtime_dir}/bus" ]]; then
        err_file=$(mktemp)
        if ! systemctl start "user@${uid}.service" >/dev/null 2>"${err_file}"; then
            err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
            if [[ -n "${err_msg}" ]]; then
                log_warn "Could not ensure user@${uid}.service for ${PODMAN_USER}: ${err_msg}"
            fi
        fi
        rm -f "${err_file}"
    fi

    err_file=$(mktemp)
    if XDG_RUNTIME_DIR="${runtime_dir}" DBUS_SESSION_BUS_ADDRESS="unix:path=${runtime_dir}/bus" runuser -u "${PODMAN_USER}" -- systemctl --user "$@" >/dev/null 2>"${err_file}"; then
        rm -f "${err_file}"
        return 0
    fi
    err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
    rm -f "${err_file}"
    log_warn "podmin systemctl (fallback) failed: ${err_msg:-unknown}; rootless services may not be active"
    return 1
}

final_summary() {
    log_info "====  Hardening completed ===="
    local summary output_dir
    summary=$(
        cat <<EOF
 Hardening completed successfully.
$( (( ENABLE_FIREWALL )) && echo " Firewall: configured (ufw)" || echo " Firewall: skipped")
$( (( ENABLE_FAIL2BAN )) && echo " Fail2ban: enabled" || echo " Fail2ban: skipped")
 Kernel: $(uname -r)
 Packages updated and installed.
 Templates installed to /usr/share/vps-harden/templates/containers
 WireGuard client configs: /root/wireguard/clients/*.conf
 Log: ${LOG_FILE}
EOF
    )
    if [[ -n "${USER_NAME}" ]] && id -u "${USER_NAME}" >/dev/null 2>&1; then
        output_dir="/home/${USER_NAME}"
    else
        output_dir="/root"
    fi
    FINAL_LOG_FILE="${output_dir}/vps-harden.log"
    echo "${summary}" > "${FINAL_LOG_FILE}"
    if [[ -n "${USER_NAME}" ]] && id -u "${USER_NAME}" >/dev/null 2>&1; then
        chown "${USER_NAME}:${USER_NAME}" "${FINAL_LOG_FILE}"
    fi
    log_info "Summary written to ${FINAL_LOG_FILE}"
}

write_user_readme() {
    local target_user="${USER_NAME}" target_home readme_path alt_readme marker dest vpn_ip gotify_port npm_port=81 kuma_port=3001 wg_client_dir="/root/wireguard/clients"
    marker="${README_MARKER}"
    gotify_port=${GOTIFY_PORT}
    vpn_ip="${WIREGUARD_SERVER_IP:-${WG_INTERFACE_ADDRESS%%/*}}"
    if [[ -z "${vpn_ip}" ]]; then
        vpn_ip="10.66.66.1"
    fi
    if [[ -z "${target_user}" ]]; then
        log_warn "No target user specified; skipping README generation"
        return
    fi
    target_home=$(getent passwd "${target_user}" | cut -d: -f6)
    if [[ -z "${target_home}" ]]; then
        log_error "Unable to determine home directory for ${target_user}"
        return
    fi
    readme_path="${target_home}/README.md"
    alt_readme="${target_home}/README.archarden.md"
    dest="${readme_path}"
    if [[ -f "${readme_path}" ]] && ! grep -qF "${marker}" "${readme_path}"; then
        dest="${alt_readme}"
    elif [[ -f "${alt_readme}" ]] && grep -qF "${marker}" "${alt_readme}"; then
        dest="${alt_readme}"
    fi

    local content
    content=$(cat <<EOF
${marker}
# Archarden: next steps after reboot

## 1. Establish WireGuard VPN connection
- Server VPN IP: ${vpn_ip}
- Client configs to retrieve:
  - ${wg_client_dir}/laptop.conf
  - ${wg_client_dir}/phone.conf
- Copy a client config securely (replace <server> with your hostname or IP):
  - scp -P ${SSH_PORT} root@<server>:${wg_client_dir}/laptop.conf .
  - (or: sudo cat ${wg_client_dir}/laptop.conf > laptop.conf)
- Bring the tunnel up on the client:
  - Linux: wg-quick up ./laptop.conf
  - Mobile: import the config into the WireGuard app
- Verify on the server:
  - sudo wg show wg0
  - Expected: peer handshakes updating for connected clients.

## 2. Bind admin ports to the VPN interface only
- Policy: admin services stay off the public internet; they should only listen on wg0.
- Apply/confirm UFW rules:
  - sudo ufw allow in on wg0 to any port ${npm_port} proto tcp comment 'NPM Admin (VPN)'
  - sudo ufw allow in on wg0 to any port ${kuma_port} proto tcp comment 'Uptime Kuma (VPN)'
  - sudo ufw allow in on wg0 to any port ${gotify_port} proto tcp comment 'Gotify (VPN)'
- Verify:
  - sudo ufw status verbose
  - ss -lntup | grep -E ':(81|3001|${gotify_port})\\b' || true
  - (Optional) External scans should NOT show these ports.

## 3. Connect to admin services (after VPN is up)
- NPM Admin: http://${vpn_ip}:${npm_port}
- Uptime Kuma: http://${vpn_ip}:${kuma_port}
- Gotify: http://${vpn_ip}:${gotify_port}

## 4. OPTIONAL (after verifying VPN works)
- Restrict SSH to the VPN only (keep console/rescue for break-glass access):
  - sudo ufw delete limit ${SSH_PORT}/tcp || sudo ufw delete allow ${SSH_PORT}/tcp
  - sudo ufw allow in on wg0 to any port ${SSH_PORT} proto tcp comment 'SSH (VPN only)'
- Restrict admin ports to wg0 if not already done:
  - sudo ufw allow in on wg0 to any port ${npm_port} proto tcp comment 'NPM Admin (VPN)'
  - sudo ufw allow in on wg0 to any port ${kuma_port} proto tcp comment 'Uptime Kuma (VPN)'
  - sudo ufw allow in on wg0 to any port ${gotify_port} proto tcp comment 'Gotify (VPN)'
- Post-VPN validation:
  - Confirm no public-facing allow/limit rules remain for SSH or admin ports.
  - Re-scan from outside the VPN to verify only expected services are exposed.
EOF
)
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would write ${dest} for ${target_user}"
        echo "${content}" | sed 's/^/    /' >&2
        return
    fi
    write_file_atomic "${dest}" <<< "${content}"
    run_cmd "chown ${target_user}:${target_user} \"${dest}\""
    run_cmd "chmod 0644 \"${dest}\""
    log_info "User README written to ${dest}"
}

archive_backups() {
    ensure_backup_root
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would archive backups from ${BACKUP_ROOT} to ${BACKUP_ARCHIVE}"
        return
    fi
    if [[ ! -d "${BACKUP_ROOT}" ]]; then
        run_cmd "install -d -m 0700 -o root -g root \"${BACKUP_ROOT}\""
    fi
    if [[ -f "${BACKUP_ARCHIVE}" ]]; then
        run_cmd "rm -f \"${BACKUP_ARCHIVE}\""
    fi
    run_cmd "umask 077 && tar -C /root -czf \"${BACKUP_ARCHIVE}\" \"archarden-backups/${RUN_ID}\""
    run_cmd "chown root:root \"${BACKUP_ARCHIVE}\""
    run_cmd "chmod 0600 \"${BACKUP_ARCHIVE}\""
    log_info "Backups archived at ${BACKUP_ARCHIVE}"
    log_info "Backup directory retained at ${BACKUP_ROOT}"
}

trigger_final_reboot() {
    log_info "==== Phase 1 completed; system will reboot in 5 seconds to finalize services and quadlets ===="
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would reboot now to complete Phase 1"
        return
    fi
    sleep 5
    run_cmd "reboot"
}

install_packages() {
    local pkgs=()
    while IFS= read -r pkg; do
        pkgs+=("${pkg}")
    done < <(read_packages_from_file "${CONFIG_DIR}/packages.list")

    if [[ ${ENABLE_AUDITD} -eq 1 ]]; then
        while IFS= read -r pkg; do
            pkgs+=("${pkg}")
        done < <(read_packages_from_file "${CONFIG_DIR}/packages.auditd.list" 1)
    fi

    while IFS= read -r pkg; do
        pkgs+=("${pkg}")
    done < <(read_packages_from_file "${CONFIG_DIR}/packages.custom.list" 1)

    apply_package_replacements pkgs

    if [[ ${#pkgs[@]} -eq 0 ]]; then
        log_warn "No packages defined for installation; skipping package installation"
        return
    fi

    log_info "Updating system and installing packages: ${pkgs[*]}"
    run_cmd "pacman -Syu --noconfirm ${pkgs[*]}"
}

install_self() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would install archarden to ${INSTALL_PREFIX} and symlink to ${INSTALL_BIN}"
        return
    fi
    if [[ "${SCRIPT_DIR}" != "${INSTALL_PREFIX}" ]]; then
        mkdir -p "${INSTALL_PREFIX}"
        run_cmd "cp -a ${SCRIPT_DIR}/. ${INSTALL_PREFIX}/"
    fi
    run_cmd "install -m 0755 ${INSTALL_PREFIX}/harden ${INSTALL_BIN}"
}

next_available_system_gid() {
    local gid used
    mapfile -t used < <(getent group | awk -F: '{print $3}')
    for gid in $(seq 999 -1 100); do
        if ! printf '%s\n' "${used[@]}" | grep -qx "${gid}"; then
            echo "${gid}"
            return 0
        fi
    done
    return 1
}

resume_needs_restore() {
    local arg resume_present=0
    for arg in "$@"; do
        if [[ "${arg}" == "--resume" ]]; then
            resume_present=1
            break
        fi
    done
    if [[ ${resume_present} -eq 1 && $# -eq 1 ]]; then
        return 0
    fi
    return 1
}

parse_args() {
    RESUME_MODE=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --hostname) SYSTEM_HOSTNAME="$2"; shift 2;;
            --user) USER_NAME="$2"; shift 2;;
            --pubkey-file) PUBKEY_FILE="$2"; shift 2;;
            --pubkey) PUBKEY_VALUE="$2"; shift 2;;
            --version) show_version; exit 0;;
            --ssh-port) SSH_PORT="$2"; shift 2;;
            --restrict-ssh-cidr) RESTRICT_SSH_CIDR="$2"; shift 2;;
            --keep-ssh-22) KEEP_SSH_22=1; shift;;
            --enable-auditd) ENABLE_AUDITD=1; shift;;
            --disable-fail2ban) ENABLE_FAIL2BAN=0; shift;;
            --disable-firewall|--disable-ufw) ENABLE_FIREWALL=0; shift;;
            --skip-firewall-enable) SKIP_FIREWALL_ENABLE=1; shift;;
            --dry-run) DRY_RUN=1; shift;;
            --resume) RESUME_MODE=1; shift;;
            -h|--help) usage; exit 0;;
            *) log_error "Unknown option: $1"; usage; exit 1;;
        esac
    done
    export DRY_RUN
}

preflight() {
    require_root
    if [[ -z "${SYSTEM_HOSTNAME}" ]]; then
        log_error "--hostname is required."
        exit 1
    fi
    if [[ -z "${USER_NAME}" ]]; then
        log_error "--user is required."
        exit 1
    fi
    if [[ -z "${PUBKEY_FILE}" && -z "${PUBKEY_VALUE}" ]]; then
        log_error "Either --pubkey-file or --pubkey is required."
        exit 1
    fi
    if ! grep -qi 'arch' /etc/os-release; then
        log_error "This tool is intended for Arch Linux systems."
        exit 1
    fi
    if ! [[ ${SSH_PORT} =~ ^[0-9]+$ ]] || (( SSH_PORT < 1 || SSH_PORT > 65535 )); then
        log_error "Invalid --ssh-port '${SSH_PORT}'. Must be 1-65535."
        exit 1
    fi
    if [[ -n "${SSH_CONNECTION:-}" ]]; then
        SSH_CONNECTION_INFO=${SSH_CONNECTION}
        log_info "Running under SSH from ${SSH_CONNECTION_INFO}"
    else
        log_warn "Not running under SSH; lockout protections limited."
    fi
}

read_packages_from_file() {
    local file="$1" optional="${2:-0}"
    if [[ ! -f "${file}" ]]; then
        if [[ "${optional}" -eq 1 ]]; then
            log_warn "Optional package list not found: ${file}; skipping"
            return
        fi
        log_error "Required package list not found: ${file}"
        exit 1
    fi

    grep -Ev '^[[:space:]]*(#|$)' "${file}"
}

apply_package_replacements() {
    local packages_var="$1"
    local -n packages_ref=${packages_var}
    local replacements_file="${CONFIG_DIR}/packages.replacements.list"
    local -a replacements=()

    while IFS= read -r line; do
        replacements+=("${line}")
    done < <(read_packages_from_file "${replacements_file}" 1)

    if [[ ${#replacements[@]} -eq 0 ]]; then
        return
    fi

    local entry current replacement
    for entry in "${replacements[@]}"; do
        read -r current replacement <<<"${entry}"
        if [[ -z "${current}" || -z "${replacement}" ]]; then
            log_warn "Skipping malformed replacement entry: ${entry}"
            continue
        fi
        if ! package_requested "${replacement}" "${packages_var}"; then
            continue
        fi
        if package_installed "${current}"; then
            replace_package "${current}" "${replacement}"
        fi
    done
}

package_requested() {
    local target="$1"
    local -n packages_ref=$2
    local pkg
    for pkg in "${packages_ref[@]}"; do
        if [[ "${pkg}" == "${target}" ]]; then
            return 0
        fi
    done
    return 1
}

package_installed() {
    local pkg="$1"
    if command -v pacman >/dev/null 2>&1; then
        pacman -Q "${pkg}" >/dev/null 2>&1
        return $?
    fi
    log_error "Unsupported package manager; cannot check installation state for ${pkg}"
    exit 1
}

replace_package() {
    local current="$1" replacement="$2"
    if command -v pacman >/dev/null 2>&1; then
        log_info "Replacing installed package ${current} with ${replacement}"
        if ! run_cmd "pacman -S --noconfirm --needed ${replacement}"; then
            log_warn "Direct install failed; retrying by removing ${current} first"
            run_cmd "pacman -Rdd --noconfirm ${current}"
            run_cmd "pacman -S --noconfirm --needed ${replacement}"
        fi
        return
    fi
    log_error "Unsupported package manager; cannot replace ${current} with ${replacement}"
    exit 1
}

record_pending_args() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would record pending args to ${PENDING_ARGS_FILE}: $*"
        return
    fi
    mkdir -p "${STATE_DIR}"

    local persisted_pubkey=""
    if [[ -n "${PUBKEY_FILE}" ]]; then
        if [[ ! -f "${PUBKEY_FILE}" ]]; then
            log_error "Public key file not found: ${PUBKEY_FILE}"
            exit 1
        fi
        persisted_pubkey="${PERSISTED_PUBKEY_FILE}"
        run_cmd "install -D -m 0644 \"${PUBKEY_FILE}\" \"${persisted_pubkey}\""
        log_info "Persisted public key for resume at ${persisted_pubkey}"
    fi

    local -a resume_args=()
    while [[ $# -gt 0 ]]; do
        if [[ "$1" == "--pubkey-file" ]]; then
            if [[ $# -lt 2 ]]; then
                log_error "Missing value for --pubkey-file when recording pending args"
                exit 1
            fi
            resume_args+=("$1")
            if [[ -n "${persisted_pubkey}" ]]; then
                resume_args+=("${persisted_pubkey}")
            else
                resume_args+=("$2")
            fi
            shift 2
            continue
        fi
        resume_args+=("$1")
        shift
    done

    printf '%q ' "${resume_args[@]}" > "${PENDING_ARGS_FILE}"
    echo >> "${PENDING_ARGS_FILE}"
}

report_services() {
    log_info "Enabled services summary:"
    status_cmd "systemctl list-unit-files --type=service --state=enabled"
}

disable_units_from_config() {
    local list_file="${CONFIG_DIR}/disable-units.list"
    if [[ ! -f "${list_file}" ]]; then
        log_warn "Disable list missing at ${list_file}; skipping"
        return
    fi

    while IFS= read -r unit || [[ -n "${unit}" ]]; do
        unit=$(echo "${unit%%#*}" | sed -E 's/^[[:space:]]+//;s/[[:space:]]+$//')
        if [[ -z "${unit}" ]]; then
            continue
        fi
        if [[ "${unit}" == *cloud-init* ]]; then
            log_warn "Skipping cloud-init unit ${unit}"
            continue
        fi
        local state
        state=$(systemctl is-enabled "${unit}" 2>/dev/null | tr -d '\r' || true)
        if [[ -z "${state}" ]]; then
            log_warn "Could not determine enable state for ${unit}; skipping"
            continue
        fi
        case "${state}" in
            enabled|enabled-runtime)
                if ! run_cmd "systemctl disable --now ${unit}"; then
                    log_warn "Failed to disable ${unit}; please review manually"
                fi
                ;;
            indirect)
                if ! run_cmd "systemctl disable --now ${unit}"; then
                    log_warn "Indirect unit ${unit} could not be disabled cleanly; please review manually"
                fi
                ;;
            static|disabled)
                if systemctl is-active --quiet "${unit}"; then
                    systemctl stop "${unit}" >/dev/null 2>&1 || true
                fi
                if [[ "${state}" == "static" ]]; then
                    log_info "${unit} is static; cannot be disabled via systemctl. Skipped disable."
                fi
                if [[ "${unit}" == "archlinux-keyring-wkd-sync.service" ]]; then
                    if systemctl is-active --quiet "archlinux-keyring-wkd-sync.timer"; then
                        systemctl stop "archlinux-keyring-wkd-sync.timer" >/dev/null 2>&1 || true
                        log_info "Stopped archlinux-keyring-wkd-sync.timer while service is inactive"
                    fi
                fi
                ;;
            *)
                log_warn "Unexpected enable state '${state}' for ${unit}; skipped"
                ;;
        esac
    done < "${list_file}"
}

ensure_default_target() {
    run_cmd "systemctl set-default multi-user.target"
    run_cmd "systemctl get-default"
}

verify_podman_runtime() {
    local uid runtime_dir runtime_output
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would verify Podman runtime as ${PODMAN_USER}"
        return
    fi
    uid=$(id -u "${PODMAN_USER}")
    runtime_dir="/run/user/${uid}"
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${runtime_dir}"
    runtime_output=$(HOME="${PODMAN_HOME:-$(eval echo \"~${PODMAN_USER}\")}" XDG_RUNTIME_DIR="${runtime_dir}" runuser -u "${PODMAN_USER}" -- podman info --format '{{.Host.OCIRuntime.Name}}' 2>/dev/null || true)
    runtime_output=$(echo "${runtime_output}" | tr -d '\r')
    if [[ "${runtime_output}" != "runc" ]]; then
        log_warn "Podman runtime reported '${runtime_output:-<empty>}' for ${PODMAN_USER}; expected 'runc'. Ensure containers.conf is applied."
    else
        log_info "Podman runtime verified as '${runtime_output}' for ${PODMAN_USER}"
    fi
}

verify_zram_swap() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would verify zram swap priority"
        return
    fi
    local swap_output zram_priority swapfile_priority
    swap_output=$(swapon --show --noheadings --raw --bytes 2>/dev/null || true)
    if [[ -z "${swap_output}" ]]; then
        log_warn "No active swap devices reported; zram may not be active."
        return
    fi
    zram_priority=$(echo "${swap_output}" | awk '$1 ~ /zram0/ {print $4}' | head -n1)
    swapfile_priority=$(echo "${swap_output}" | awk '$1 ~ /swapfile/ {print $4}' | head -n1)
    if echo "${swap_output}" | grep -q '/dev/zram0'; then
        log_info "zram device detected in swap list."
    else
        log_warn "zram device /dev/zram0 not present in swap list."
    fi
    if [[ -n "${zram_priority}" && -n "${swapfile_priority}" ]]; then
        if (( zram_priority > swapfile_priority )); then
            log_info "zram priority (${zram_priority}) is higher than swapfile (${swapfile_priority})."
        else
            log_warn "zram priority (${zram_priority:-unset}) is not higher than swapfile (${swapfile_priority:-unset})."
        fi
    else
        log_warn "Could not determine swap priorities for zram and swapfile; review swapon output manually."
    fi
}

restore_sshd_dropins() {
    local restored=0 dropin latest_backup backup_pattern
    for dropin in "${SSHD_HARDENING_DROPIN}" "${SSHD_CRYPTO_DROPIN}"; do
        latest_backup=""
        if [[ -n "${BACKUP_ROOT:-}" ]]; then
            backup_pattern="${BACKUP_ROOT}/configs/${dropin#/}"
            latest_backup=$(ls -1t "${backup_pattern}".*.bak 2>/dev/null | head -n1 || true)
        fi
        if [[ -z "${latest_backup}" ]]; then
            latest_backup=$(ls -1t "${dropin}".*.bak 2>/dev/null | head -n1 || true)
        fi
        if [[ -n "${latest_backup}" ]]; then
            run_cmd "cp -p \"${latest_backup}\" \"${dropin}\""
            restored=1
        elif [[ -f "${dropin}" ]]; then
            run_cmd "rm -f ${dropin}"
            restored=1
            log_warn "Removed ${dropin} after failure; no backup was available."
        fi
    done
    if [[ ${restored} -eq 1 ]]; then
        log_warn "Restored previous sshd drop-ins from backups after failure."
    fi
    return ${restored}
}

log_sshd_effective_crypto() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would log effective sshd crypto configuration"
        return
    fi
    status_cmd "sshd -T | grep -E 'kexalgorithms|ciphers|macs|hostkeyalgorithms|pubkeyacceptedalgorithms' || true"
}

verify_sshd_port() {
    if ss -tulpn | grep -q ":${SSH_PORT}"; then
        return 0
    fi
    return 1
}

restart_sshd_and_verify() {
    if [ "${DRY_RUN}" -eq 0 ]; then
        if run_cmd "systemctl restart sshd"; then
            if verify_sshd_port; then
                log_sshd_effective_crypto
                return
            fi
            log_error "sshd is not listening on port ${SSH_PORT} after restart"
        else
            log_error "sshd restart failed"
        fi
        log_warn "Attempting to restore previous sshd configuration after restart failure"
        restore_sshd_dropins
        if sshd -t && run_cmd "systemctl restart sshd" && verify_sshd_port; then
            log_warn "Restored previous sshd drop-ins after restart failure"
            log_sshd_effective_crypto
            return
        fi
        log_error "Unable to recover sshd service after restart failure; manual intervention required."
        exit 1
    else
        log_info "[DRY-RUN] Would restart sshd and verify port ${SSH_PORT}"
    fi
}

rotate_sshd_host_keys() {
    local ts backup_dir rotation_failed=0
    ts=$(date -u '+%Y%m%d%H%M%S')
    ensure_backup_root
    backup_dir="${BACKUP_ROOT}/${SSH_HOSTKEY_BACKUP_CATEGORY}/${ts}"

    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would backup host keys to ${backup_dir}, regenerate with ssh-keygen -A, and restart sshd"
        return
    fi

    run_cmd "install -d -m 0700 -o root -g root \"${backup_dir}\""
    if ls /etc/ssh/ssh_host_* >/dev/null 2>&1; then
        run_cmd "cp -a /etc/ssh/ssh_host_* \"${backup_dir}/\""
        BACKUP_PATHS+=("${backup_dir}")
        log_info "Backed up existing ssh host keys to ${backup_dir}"
    else
        log_warn "No existing ssh host keys found before rotation"
    fi

    if ! run_cmd "systemctl stop sshd"; then
        log_warn "Could not stop sshd for host key rotation; skipping rotation"
        return
    fi

    if ! run_cmd "rm -f /etc/ssh/ssh_host_*"; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! run_cmd "ssh-keygen -A"; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! run_cmd "systemctl start sshd"; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! sshd -t; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! systemctl is-active --quiet sshd; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! verify_sshd_port; then
        log_warn "sshd port verification failed after host key rotation"
        rotation_failed=1
    fi

    if [[ ${rotation_failed} -eq 0 ]]; then
        log_info "sshd is listening on port ${SSH_PORT} after host key rotation"
        log_warn "Host keys rotated. Clients will see a host key change and must update known_hosts."
        log_sshd_effective_crypto
        return
    fi

    log_warn "Host key rotation failed; attempting to restore previous keys from ${backup_dir}"
    run_cmd "rm -f /etc/ssh/ssh_host_*"
    if ls "${backup_dir}"/ssh_host_* >/dev/null 2>&1; then
        run_cmd "cp -a \"${backup_dir}\"/ssh_host_* /etc/ssh/"
    fi
    if sshd -t && run_cmd "systemctl restart sshd" && verify_sshd_port; then
        log_warn "Restored previous sshd host keys after rotation failure."
        log_sshd_effective_crypto
        return
    fi
    log_error "Restoration after failed host key rotation did not succeed; sshd may be unavailable."
    exit 1
}

status_cmd() {
    local cmd="$*"
    log_info "Status: ${cmd}"
    eval "${cmd}"
}

status_report() {
    log_info "==== STATUS REPORT ===="
    status_cmd "ss -tulnp || true"
    if command -v ufw >/dev/null 2>&1; then
        status_cmd "ufw status verbose || true"
    fi
    if systemctl list-unit-files --type=service | grep -q fail2ban.service; then
        status_cmd "systemctl status fail2ban --no-pager || true"
    fi
    report_services
    if [[ ${#BACKUP_PATHS[@]} -gt 0 ]]; then
        log_info "Backups created: ${BACKUP_PATHS[*]}"
    fi
}

usage() {
    printf "%s\n" "$(bold "Usage:") $(cyan "sudo ./harden [options]")"
    printf "\n%s\n" "$(bold "$(green "Required")")"
    printf "  %s\n" "$(cyan "--hostname <name>")          Set the system hostname."
    printf "  %s\n" "$(cyan "--user <name>")              Create or ensure admin user exists and in wheel group."
    printf "  %s\n" "$(cyan "--pubkey-file <path>")       Public key file to install for the admin user."
    printf "  %s\n" "$(cyan "--pubkey \"<key>\"")           Public key string to install for the admin user."

    printf "\n%s\n" "$(bold "$(green "SSH")")"
    printf "  %s\n" "$(cyan "--ssh-port <port>")          SSH port to configure (default: 2122)."
    printf "  %s\n" "$(cyan "--restrict-ssh-cidr <C>")    Restrict SSH via UFW to the given CIDR."
    printf "  %s\n" "$(cyan "--keep-ssh-22")              Keep port 22 allowed (transition)."

    printf "\n%s\n" "$(bold "$(green "Optional services")")"
    printf "  %s\n" "$(cyan "--enable-auditd")            Install and enable auditd."
    printf "  %s\n" "$(cyan "--disable-fail2ban")         Skip fail2ban configuration."
    printf "  %s\n" "$(cyan "--disable-firewall")         Skip firewall configuration (alias: --disable-ufw)."
    printf "  %s\n" "$(cyan "--skip-firewall-enable")     Write UFW rules but do not enable the firewall."

    printf "\n%s\n" "$(bold "$(green "Behavior")")"
    printf "  %s\n" "$(cyan "--dry-run")                  Show actions without changing the system."
    printf "  %s\n" "$(cyan "--resume")                   Internal flag: resume after reboot; do not re-arm continuation."
    printf "  %s\n" "$(cyan "--version")                  Show version and exit."
    printf "  %s\n" "$(cyan "-h, --help")                 Show this help."
}

verify_nf_tables_after_reboot() {
    if [[ ${RESUME_MODE} -eq 0 ]]; then
        return
    fi
    status_cmd "lsmod | grep -E 'nf_tables|nfnetlink' || true"
}

write_continue_service() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would install continuation service at ${CONTINUE_SERVICE}"
        return
    fi
    render_template "${CONTINUE_SERVICE_TEMPLATE}" "${CONTINUE_SERVICE}" \
        "PENDING_ARGS_FILE=${PENDING_ARGS_FILE}" \
        "INSTALL_PREFIX=${INSTALL_PREFIX}"
    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable vps-harden-continue.service"
}

show_version() {
    local version_file="${SCRIPT_DIR}/VERSION"
    if [[ -f "${version_file}" ]]; then
        cat "${version_file}"
    else
        echo "unknown"
    fi
}

    main() {
        local answer_file="${SCRIPT_DIR}/harden.params" file_args cli_args cli_has_dry_run=0 file_has_dry_run=0

        cli_args=("$@")

        if [[ "$#" -gt 0 && "$1" == "--resume" ]]; then
            :
        else
            if [[ -f "${answer_file}" ]]; then
                file_args=$(sed -e 's/[[:space:]]*#.*$//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' "${answer_file}" | tr '\n' ' ')
                log_info "Using parameter file ${answer_file}; overriding CLI arguments"
                if [[ -n "${file_args//[[:space:]]/}" ]]; then
                    if [[ " ${file_args} " == *" --dry-run "* ]]; then
                        file_has_dry_run=1
                fi
                eval "set -- ${file_args}"
            else
                set --
            fi
        fi
    fi

    for arg in "${cli_args[@]}"; do
        if [[ "${arg}" == "--dry-run" ]]; then
            cli_has_dry_run=1
            break
        fi
    done
    if [[ ${cli_has_dry_run} -eq 1 && ${file_has_dry_run} -eq 0 ]]; then
        set -- "$@" --dry-run
    fi

    if resume_needs_restore "$@"; then
        if [[ ! -s "${PENDING_ARGS_FILE}" ]]; then
            log_error "Resume requested but pending args missing at ${PENDING_ARGS_FILE}"
            exit 1
        fi
        local saved_args
        saved_args=$(cat "${PENDING_ARGS_FILE}")
        log_info "Resume requested without parameters; restoring saved arguments from ${PENDING_ARGS_FILE}"
        eval "set -- --resume ${saved_args}"
    fi

    parse_args "$@"
    preflight
    initialize_run_context
    install_self
    clear_pending_state
    ensure_lts_kernel_and_reboot_gate "$@"
    switch_to_phase1_logging
    verify_nf_tables_after_reboot
    install_packages
    enable_timesync
    configure_journald
    configure_sysctl
    configure_vm_tuning_sysctl
    apply_sysctl_settings
    configure_tmp_mount
    configure_zram
    configure_hostname
    ensure_ssh_group
    create_admin_user
    ensure_podmin_user
    configure_podman_runtime
    configure_sshd
    restart_sshd_and_verify
    rotate_sshd_host_keys
    configure_wireguard
    configure_ufw
    configure_fail2ban
    configure_podman_templates
    configure_rootless_quadlets
    configure_podman_api_proxy
    configure_socket_proxyd
    configure_gotify_notifications
    verify_podman_runtime
    verify_zram_swap
    ensure_default_target
    disable_units_from_config
    status_report
    final_summary
    write_user_readme
    archive_backups
    trigger_final_reboot
}

main "$@"

show_version() {
    local version_file="${SCRIPT_DIR}/VERSION"
    if [[ -f "${version_file}" ]]; then
        cat "${version_file}"
    else
        echo "unknown"
    fi
}
