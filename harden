#!/usr/bin/env bash
# SPDX-License-Identifier: AGPL-3.0-or-later
# Copyright (c) 2025 Richard Majewski
set -eEuo pipefail

PHASE0_LOG="/var/log/vps-harden.phase0.log"
PHASE1_LOG="/var/log/vps-harden.phase1.log"
LOG_FILE="${PHASE0_LOG}"
CURRENT_PHASE="phase0"
for arg in "$@"; do
    if [[ "${arg}" == "--resume" ]]; then
        LOG_FILE="${PHASE1_LOG}"
        CURRENT_PHASE="phase1"
        break
    fi
done

DEFAULT_INSTALL_PREFIX="/usr/local/lib/vps-harden"
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
if [[ ! -f "${SCRIPT_DIR}/lib/utils.sh" ]]; then
    FALLBACK_DIR="${DEFAULT_INSTALL_PREFIX}"
    if [[ -f "${FALLBACK_DIR}/lib/utils.sh" ]]; then
        SCRIPT_DIR="${FALLBACK_DIR}"
    else
        printf 'Required helper not found: %s\n' "${SCRIPT_DIR}/lib/utils.sh" >&2
        exit 1
    fi
fi
CONFIG_DIR="${SCRIPT_DIR}/config"
TEMPLATES_DIR="${SCRIPT_DIR}/templates"
source "${SCRIPT_DIR}/lib/utils.sh"

DRY_RUN=0
ENABLE_FAIL2BAN=1
ENABLE_FIREWALL=1
ENABLE_LINGER=1
SKIP_FIREWALL_ENABLE=0
KEEP_SSH_22=0
RESTRICT_SSH_CIDR=""
USER_NAME=""
USER_HOME=""
PUBKEY_FILE=""
PUBKEY_VALUE=""
ENABLE_AUDITD=0
NON_INTERACTIVE=0
SYSTEM_HOSTNAME=""
SSH_PORT=2122
SSH_CONNECTION_INFO=""
GRUB_LTS_ENTRY="Advanced options for Arch Linux>Arch Linux, with Linux linux-lts"
GRUB_CONFIG_PATH="/boot/grub/grub.cfg"
INSTALL_PREFIX="${DEFAULT_INSTALL_PREFIX}"
INSTALL_BIN="/usr/local/bin/vps-harden"
STATE_DIR="/var/lib/vps-harden"
PENDING_ARGS_FILE="${STATE_DIR}/pending_args"
CONTINUE_SERVICE="/etc/systemd/system/vps-harden-continue.service"
CONTINUE_SERVICE_TEMPLATE="${TEMPLATES_DIR}/systemd/vps-harden-continue.service"
FINAL_LOG_FILE=""

clear_pending_state() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would clear pending state at ${PENDING_ARGS_FILE}"
        return
    fi
    rm -f "${PENDING_ARGS_FILE}"
}

configure_fail2ban() {
    if [[ ${ENABLE_FAIL2BAN} -eq 0 ]]; then
        log_warn "Fail2ban disabled by flag"
        return
    fi
    backup_file /etc/fail2ban/jail.local
    sed "s/__SSH_PORT__/${SSH_PORT}/g" "${CONFIG_DIR}/fail2ban_jail.local" | write_file_atomic /etc/fail2ban/jail.local
    run_cmd "systemctl enable --now fail2ban.service"
    if [ "${DRY_RUN}" -eq 0 ]; then
        status_cmd "fail2ban-client status sshd || true"
    fi
}

configure_hostname() {
    if [[ -z "${SYSTEM_HOSTNAME}" ]]; then
        return
    fi
    run_cmd "hostnamectl set-hostname ${SYSTEM_HOSTNAME}"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        return
    fi
    log_info "Hostname set to ${SYSTEM_HOSTNAME}"
}

configure_journald() {
    backup_file /etc/systemd/journald.conf
    write_file_atomic /etc/systemd/journald.conf < "${CONFIG_DIR}/journald.conf"
    run_cmd "systemctl restart systemd-journald"
}

configure_podman_templates() {
    local dest_dir=/usr/share/vps-harden/templates/containers
    write_file_atomic /usr/share/vps-harden/README <<'EOT'
Podman templates installed by vps-harden.
EOT
    write_file_atomic "${dest_dir}/nginx-proxy-manager.container" < "${TEMPLATES_DIR}/containers/nginx-proxy-manager.container"
    write_file_atomic "${dest_dir}/podman-run-npm.sh" < "${TEMPLATES_DIR}/containers/podman-run-npm.sh"
    write_file_atomic "${dest_dir}/gotify.container" < "${TEMPLATES_DIR}/containers/gotify.container"
    write_file_atomic "${dest_dir}/podman-run-gotify.sh" < "${TEMPLATES_DIR}/containers/podman-run-gotify.sh"
    run_cmd "chmod +x ${dest_dir}/podman-run-npm.sh"
    run_cmd "chmod +x ${dest_dir}/podman-run-gotify.sh"
}

ensure_containers_runtime_config() {
    local target="$1" owner="${2:-root}" group="${3:-root}"
    local runtime_line='runtime = "runc"'
    local tmp in_engine=0 runtime_set=0 found_engine=0
    tmp=$(mktemp)

    run_cmd "install -d -m 0755 -o ${owner} -g ${group} $(dirname "${target}")"

    if [[ -f "${target}" ]]; then
        while IFS= read -r line || [[ -n "${line}" ]]; do
            if [[ "${line}" =~ ^\[.*\] ]]; then
                if [[ ${in_engine} -eq 1 && ${runtime_set} -eq 0 ]]; then
                    echo "${runtime_line}" >>"${tmp}"
                fi
                in_engine=0
            fi
            if [[ "${line}" =~ ^\[engine\] ]]; then
                found_engine=1
                in_engine=1
                runtime_set=0
            fi
            if [[ ${in_engine} -eq 1 && "${line}" =~ ^runtime[[:space:]]*= ]]; then
                line=${runtime_line}
                runtime_set=1
            fi
            echo "${line}" >>"${tmp}"
        done < "${target}"
    fi

    if [[ ${in_engine} -eq 1 && ${runtime_set} -eq 0 ]]; then
        echo "${runtime_line}" >>"${tmp}"
    fi

    if [[ ${found_engine} -eq 0 ]]; then
        [[ -s "${tmp}" ]] && echo >>"${tmp}"
        {
            echo "[engine]"
            echo "${runtime_line}"
        } >>"${tmp}"
    fi

    write_file_atomic "${target}" < "${tmp}"
    rm -f "${tmp}"
    if [[ "${owner}" != "root" || "${group}" != "root" ]]; then
        run_cmd "chown ${owner}:${group} ${target}"
    fi
}

configure_podman_runtime() {
    local user_home
    user_home="${USER_HOME:-$(getent passwd "${USER_NAME}" | cut -d: -f6)}"
    if [[ -z "${user_home}" ]]; then
        log_error "Unable to determine home for ${USER_NAME}"
        exit 1
    fi
    ensure_containers_runtime_config /etc/containers/containers.conf root root
    ensure_containers_runtime_config "${user_home}/.config/containers/containers.conf" "${USER_NAME}" "${USER_NAME}"
}

ensure_npm_quadlet() {
    local user_home systemd_dir target input tmp_out
    user_home="${USER_HOME:-$(getent passwd "${USER_NAME}" | cut -d: -f6)}"
    if [[ -z "${user_home}" ]]; then
        log_error "Unable to determine home for ${USER_NAME}"
        exit 1
    fi
    systemd_dir="${user_home}/.config/containers/systemd"
    target="${systemd_dir}/nginx-proxy-manager.container"
    input="${target}"
    run_cmd "install -d -m 0755 -o ${USER_NAME} -g ${USER_NAME} ${systemd_dir}"
    if [[ ! -f "${input}" ]]; then
        input="${TEMPLATES_DIR}/containers/nginx-proxy-manager.container"
    fi

    tmp_out=$(mktemp)
    local in_container=0 saw_memory=0 saw_pids=0 saw_podmanargs=0
    local -a required_ports=("127.0.0.1:8181:81" "127.0.0.1:8080:80" "127.0.0.1:8443:443")
    declare -A port_seen
    for port in "${required_ports[@]}"; do
        port_seen["${port}"]=0
    done

    while IFS= read -r line || [[ -n "${line}" ]]; do
        if [[ "${line}" =~ ^\[.*\] ]]; then
            if [[ ${in_container} -eq 1 ]]; then
                for port in "${required_ports[@]}"; do
                    if [[ ${port_seen[${port}]} -eq 0 ]]; then
                        echo "PublishPort=${port}" >>"${tmp_out}"
                        port_seen["${port}"]=1
                    fi
                done
                if [[ ${saw_memory} -eq 0 ]]; then
                    echo "Memory=512M" >>"${tmp_out}"
                fi
                if [[ ${saw_pids} -eq 0 ]]; then
                    echo "PidsLimit=512" >>"${tmp_out}"
                fi
                if [[ ${saw_podmanargs} -eq 0 ]]; then
                    echo "PodmanArgs=--memory-swap=1G" >>"${tmp_out}"
                fi
            fi
            in_container=0
        fi

        if [[ ${in_container} -eq 1 ]]; then
            if [[ "${line}" =~ ^PublishPort= ]]; then
                local port_value
                port_value=${line#PublishPort=}
                if [[ "${port_value}" == "80:80" || "${port_value}" == "443:443" ]]; then
                    continue
                fi
                if [[ -n "${port_seen[${port_value}]+x}" ]]; then
                    if [[ ${port_seen[${port_value}]} -eq 1 ]]; then
                        continue
                    fi
                    port_seen["${port_value}"]=1
                fi
                echo "PublishPort=${port_value}" >>"${tmp_out}"
                continue
            fi

            if [[ "${line}" =~ ^Memory= ]]; then
                if [[ ${saw_memory} -eq 1 ]]; then
                    continue
                fi
                line="Memory=512M"
                saw_memory=1
            fi
            if [[ "${line}" =~ ^PidsLimit= ]]; then
                if [[ ${saw_pids} -eq 1 ]]; then
                    continue
                fi
                line="PidsLimit=512"
                saw_pids=1
            fi
            if [[ "${line}" =~ ^Network= ]]; then
                if [[ "${line}" == "Network=host" ]]; then
                    line="Network=slirp4netns"
                fi
            fi
            if [[ "${line}" =~ ^PodmanArgs= ]]; then
                if [[ ${saw_podmanargs} -eq 1 ]]; then
                    continue
                fi
                saw_podmanargs=1
                if [[ "${line}" != *"--memory-swap=1G"* ]]; then
                    line="${line} --memory-swap=1G"
                fi
            fi
        fi

        echo "${line}" >>"${tmp_out}"

        if [[ "${line}" == "[Container]" ]]; then
            in_container=1
            saw_memory=0
            saw_pids=0
            saw_podmanargs=0
            for port in "${required_ports[@]}"; do
                port_seen["${port}"]=0
            done
        fi
    done < "${input}"

    if [[ ${in_container} -eq 1 ]]; then
        for port in "${required_ports[@]}"; do
            if [[ ${port_seen[${port}]} -eq 0 ]]; then
                echo "PublishPort=${port}" >>"${tmp_out}"
            fi
        done
        if [[ ${saw_memory} -eq 0 ]]; then
            echo "Memory=512M" >>"${tmp_out}"
        fi
        if [[ ${saw_pids} -eq 0 ]]; then
            echo "PidsLimit=512" >>"${tmp_out}"
        fi
        if [[ ${saw_podmanargs} -eq 0 ]]; then
            echo "PodmanArgs=--memory-swap=1G" >>"${tmp_out}"
        fi
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_out}"
    run_cmd "chown ${USER_NAME}:${USER_NAME} ${target}"
}

ensure_gotify_quadlet() {
    local user_home systemd_dir target input tmp_out
    user_home="${USER_HOME:-$(getent passwd "${USER_NAME}" | cut -d: -f6)}"
    if [[ -z "${user_home}" ]]; then
        log_error "Unable to determine home for ${USER_NAME}"
        exit 1
    fi
    systemd_dir="${user_home}/.config/containers/systemd"
    target="${systemd_dir}/gotify.container"
    input="${target}"
    run_cmd "install -d -m 0755 -o ${USER_NAME} -g ${USER_NAME} ${systemd_dir}"
    if [[ ! -f "${input}" ]]; then
        input="${TEMPLATES_DIR}/containers/gotify.container"
    fi

    tmp_out=$(mktemp)
    local in_container=0 saw_memory=0 saw_pids=0

    while IFS= read -r line || [[ -n "${line}" ]]; do
        if [[ "${line}" =~ ^\[.*\] ]]; then
            if [[ ${in_container} -eq 1 ]]; then
                if [[ ${saw_memory} -eq 0 ]]; then
                    echo "Memory=128M" >>"${tmp_out}"
                fi
                if [[ ${saw_pids} -eq 0 ]]; then
                    echo "PidsLimit=256" >>"${tmp_out}"
                fi
            fi
            in_container=0
        fi

        if [[ ${in_container} -eq 1 ]]; then
            if [[ "${line}" =~ ^Memory= ]]; then
                if [[ ${saw_memory} -eq 1 ]]; then
                    continue
                fi
                line="Memory=128M"
                saw_memory=1
            fi
            if [[ "${line}" =~ ^PidsLimit= ]]; then
                if [[ ${saw_pids} -eq 1 ]]; then
                    continue
                fi
                line="PidsLimit=256"
                saw_pids=1
            fi
        fi

        echo "${line}" >>"${tmp_out}"

        if [[ "${line}" == "[Container]" ]]; then
            in_container=1
            saw_memory=0
            saw_pids=0
        fi
    done < "${input}"

    if [[ ${in_container} -eq 1 ]]; then
        if [[ ${saw_memory} -eq 0 ]]; then
            echo "Memory=128M" >>"${tmp_out}"
        fi
        if [[ ${saw_pids} -eq 0 ]]; then
            echo "PidsLimit=256" >>"${tmp_out}"
        fi
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_out}"
    run_cmd "chown ${USER_NAME}:${USER_NAME} ${target}"
}

configure_rootless_quadlets() {
    ensure_npm_quadlet
    ensure_gotify_quadlet
    if ! user_systemctl "${USER_NAME}" "daemon-reload"; then
        log_warn "Failed to reload user systemd daemon for ${USER_NAME}"
    fi
    if ! user_systemctl "${USER_NAME}" "enable --now nginx-proxy-manager.service"; then
        log_warn "Failed to enable nginx-proxy-manager.service for ${USER_NAME}"
    fi
    if ! user_systemctl "${USER_NAME}" "enable --now gotify.service"; then
        log_warn "Failed to enable gotify.service for ${USER_NAME}"
    fi
}

configure_socket_proxyd() {
    local http_socket=/etc/systemd/system/archarden-http.socket
    local http_service=/etc/systemd/system/archarden-http.service
    local https_socket=/etc/systemd/system/archarden-https.socket
    local https_service=/etc/systemd/system/archarden-https.service

    backup_file "${http_socket}"
    backup_file "${http_service}"
    backup_file "${https_socket}"
    backup_file "${https_service}"

    write_file_atomic "${http_socket}" <<'EOT'
[Socket]
ListenStream=80
Accept=no

[Install]
WantedBy=sockets.target
EOT

    write_file_atomic "${http_service}" <<'EOT'
[Unit]
Requires=archarden-http.socket

[Service]
ExecStart=/usr/lib/systemd/systemd-socket-proxyd 127.0.0.1:8080
StandardInput=socket
EOT

    write_file_atomic "${https_socket}" <<'EOT'
[Socket]
ListenStream=443
Accept=no

[Install]
WantedBy=sockets.target
EOT

    write_file_atomic "${https_service}" <<'EOT'
[Unit]
Requires=archarden-https.socket

[Service]
ExecStart=/usr/lib/systemd/systemd-socket-proxyd 127.0.0.1:8443
StandardInput=socket
EOT

    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable --now archarden-http.socket archarden-https.socket"
}

configure_sshd() {
    local sshd_dir=/etc/ssh/sshd_config.d
    mkdir -p "${sshd_dir}"
    run_cmd "ssh-keygen -A"
    local kex_line
    kex_line="$(detect_kex)"
    local dropin="${sshd_dir}/10-hardening.conf"
    backup_file "${dropin}"
    sed "s/__SSH_PORT__/${SSH_PORT}/g" "${CONFIG_DIR}/sshd_hardening.conf" | write_file_atomic "${dropin}"
    if [[ -n "${kex_line}" ]]; then
        append_if_missing "${dropin}" "${kex_line}"
    fi
    if [ "${DRY_RUN}" -eq 0 ]; then
        if ! sshd -t; then
            log_error "sshd configuration failed validation"
            exit 1
        fi
    else
        log_info "[DRY-RUN] Skipping sshd validation"
    fi
}

configure_sysctl() {
    backup_file /etc/sysctl.d/99-hardening.conf
    write_file_atomic /etc/sysctl.d/99-hardening.conf < "${CONFIG_DIR}/sysctl_hardening.conf"
}

configure_vm_tuning_sysctl() {
    local dest=/etc/sysctl.d/99-vm-tuning.conf
    backup_file "${dest}"
    write_file_atomic "${dest}" < "${CONFIG_DIR}/vm-tuning.conf"
}

apply_sysctl_settings() {
    run_cmd "sysctl --system"
}

configure_tmp_mount() {
    backup_file /etc/systemd/system/tmp.mount
    write_file_atomic /etc/systemd/system/tmp.mount < "${CONFIG_DIR}/tmp.mount"
    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable --now tmp.mount"
}

configure_zram() {
    local dest=/etc/systemd/zram-generator.conf
    backup_file "${dest}"
    write_file_atomic "${dest}" < "${CONFIG_DIR}/zram-generator.conf"
    run_cmd "systemctl daemon-reload"
    if ! run_cmd "systemctl restart systemd-zram-setup@zram0.service"; then
        log_warn "systemd-zram-setup@zram0.service not available; ensure zram-generator is installed and units exist."
    fi
}

configure_ufw() {
    if [[ ${ENABLE_FIREWALL} -eq 0 ]]; then
        log_warn "Firewall configuration disabled by flag"
        return
    fi
    ensure_firewall_backend

    if ! command -v ufw >/dev/null 2>&1; then
        log_error "ufw command not found; install the ufw package."
        exit 1
    fi

    backup_file /etc/default/ufw
    run_cmd "sed -i 's/^IPV6=.*/IPV6=yes/' /etc/default/ufw || echo 'IPV6=yes' >> /etc/default/ufw"
    run_cmd "ufw --force reset"
    run_cmd "ufw default deny incoming"
    run_cmd "ufw default allow outgoing"

    if ufw --version 2>/dev/null | grep -qi nftables; then
        log_info "UFW reports nftables backend"
    else
        log_warn "UFW backend is not reporting nftables; ensure iptables-nft is the active alternative."
    fi

    if [[ -n "${RESTRICT_SSH_CIDR}" ]]; then
        run_cmd "ufw allow from ${RESTRICT_SSH_CIDR} to any port ${SSH_PORT} proto tcp"
    else
        run_cmd "ufw limit ${SSH_PORT}/tcp"
    fi

    if ss -tulpn 2>/dev/null | grep -q ':22'; then
        run_cmd "ufw allow 22/tcp"
    fi
    if [[ ${KEEP_SSH_22} -eq 1 ]]; then
        run_cmd "ufw allow 22/tcp"
    fi

    local allowlist_entries=()
    while IFS= read -r port; do
        allowlist_entries+=("${port}")
    done < <(read_packages_from_file "${CONFIG_DIR}/firewall_allow.list" 1)

    if [[ ${#allowlist_entries[@]} -eq 0 ]]; then
        log_warn "No firewall allowlist entries defined; skipping port allows"
    else
        for port in "${allowlist_entries[@]}"; do
            run_cmd "ufw allow ${port}"
        done
    fi

    if [[ ${SKIP_FIREWALL_ENABLE} -eq 1 ]]; then
        log_warn "Skipping firewall enable as requested"
        return
    fi

    run_cmd "ufw --force enable"
    if [[ ${KEEP_SSH_22} -eq 0 ]]; then
        if [ "${DRY_RUN}" -eq 0 ]; then
            ufw delete allow 22/tcp >/dev/null 2>&1 || true
        else
            log_info "[DRY-RUN] Would remove legacy SSH port 22 rule"
        fi
    fi
    run_cmd "ufw reload"
}

create_admin_user() {
    if [[ -z "${USER_NAME}" ]]; then
        return
    fi
    if id -u "${USER_NAME}" >/dev/null 2>&1; then
        log_info "User ${USER_NAME} already exists"
    else
        run_cmd "useradd -m -G wheel,ssh -s /bin/bash ${USER_NAME}"
        log_info "Created user ${USER_NAME} and added to wheel,ssh"
    fi
    ensure_user_in_group "${USER_NAME}" wheel
    ensure_user_in_group "${USER_NAME}" ssh
    if [[ ${ENABLE_LINGER} -eq 1 ]]; then
        run_cmd "loginctl enable-linger ${USER_NAME}"
    fi
    if [[ -n "${PUBKEY_FILE}" ]]; then
        PUBKEY_VALUE=$(cat "${PUBKEY_FILE}")
    fi
    if [[ -n "${PUBKEY_VALUE}" ]]; then
        local ssh_dir="/home/${USER_NAME}/.ssh"
        run_cmd "install -d -m 700 -o ${USER_NAME} -g ${USER_NAME} ${ssh_dir}"
        local auth_keys="${ssh_dir}/authorized_keys"
        if [ "${DRY_RUN}" -eq 0 ]; then
            if [ ! -f "${auth_keys}" ]; then
                touch "${auth_keys}"
                chown "${USER_NAME}:${USER_NAME}" "${auth_keys}"
                chmod 600 "${auth_keys}"
            fi
            if ! grep -qxF "${PUBKEY_VALUE}" "${auth_keys}"; then
                echo "${PUBKEY_VALUE}" >>"${auth_keys}"
            fi
        else
            log_info "[DRY-RUN] Would add key for ${USER_NAME}"
        fi
    else
        log_warn "No public key provided for ${USER_NAME}; ensure key-based auth manually."
    fi

    USER_HOME=$(getent passwd "${USER_NAME}" | cut -d: -f6)
}

detect_kex() {
    if command -v ssh >/dev/null 2>&1; then
        if ssh -Q kex 2>/dev/null | grep -q 'sntrup761x25519-sha512@openssh.com'; then
            echo "KexAlgorithms sntrup761x25519-sha512@openssh.com"
        fi
    fi
}

enable_timesync() {
    run_cmd "systemctl enable --now systemd-timesyncd.service"
}

ensure_firewall_backend() {
    if ! command -v nft >/dev/null 2>&1; then
        log_error "nft command not found; firewall configuration cannot continue."
        exit 1
    fi

    if nft list tables >/dev/null 2>&1; then
        return
    fi

    log_warn "nftables backend unavailable; attempting to load firewall kernel modules"
    local modules=()
    while IFS= read -r mod; do
        modules+=("${mod}")
    done < <(read_packages_from_file "${CONFIG_DIR}/firewall_modules.list")
    for mod in "${modules[@]}"; do
        if modinfo "${mod}" >/dev/null 2>&1; then
            run_cmd "modprobe ${mod} || true"
        fi
    done

    if nft list tables >/dev/null 2>&1; then
        log_info "Firewall kernel modules loaded successfully"
        return
    fi

    log_error "nftables backend still unavailable. Ensure firewall kernel modules are present or rerun with --skip-firewall-enable or --disable-firewall."
    exit 1
}

ensure_grub_defaults_saved() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would ensure /etc/default/grub has GRUB_DEFAULT=saved and GRUB_SAVEDEFAULT=true"
        return
    fi
    if [[ ! -f /etc/default/grub ]]; then
        log_error "/etc/default/grub not found; cannot set GRUB_DEFAULT/GRUB_SAVEDEFAULT."
        exit 1
    fi
    backup_file /etc/default/grub
    if grep -q '^GRUB_DEFAULT=' /etc/default/grub; then
        run_cmd "sed -i 's/^GRUB_DEFAULT=.*/GRUB_DEFAULT=saved/' /etc/default/grub"
    else
        run_cmd "echo 'GRUB_DEFAULT=saved' >> /etc/default/grub"
    fi
    if grep -q '^GRUB_SAVEDEFAULT=' /etc/default/grub; then
        run_cmd "sed -i 's/^GRUB_SAVEDEFAULT=.*/GRUB_SAVEDEFAULT=true/' /etc/default/grub"
    else
        run_cmd "echo 'GRUB_SAVEDEFAULT=true' >> /etc/default/grub"
    fi
}

ensure_lts_kernel_and_reboot_gate() {
    if ! command -v grub-mkconfig >/dev/null 2>&1; then
        log_error "grub-mkconfig not found; unable to set linux-lts as default."
        exit 1
    fi
    if ! command -v grub-set-default >/dev/null 2>&1; then
        log_error "grub-set-default not found; unable to set linux-lts as default."
        exit 1
    fi
    if ! command -v grub-editenv >/dev/null 2>&1; then
        log_error "grub-editenv not found; unable to verify default boot entry."
        exit 1
    fi

    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would fully upgrade, install linux-lts, regenerate GRUB, set default to '${GRUB_LTS_ENTRY}', verify grub-editenv, and require reboot before hardening."
        return
    fi

    local current_kernel saved_entry
    current_kernel=$(uname -r)
    saved_entry=$(grub-editenv list 2>/dev/null | awk -F= '/^saved_entry=/{print $2}' || true)

    if [[ "${current_kernel}" == *-lts ]] && [[ "${saved_entry}" == "${GRUB_LTS_ENTRY}" ]]; then
        log_info "System already booted into linux-lts with GRUB default set; continuing with hardening."
        return
    fi

    log_info "Pre-hardening: updating system and preparing linux-lts default boot entry."
    if ! {
        run_cmd "pacman -Syu --noconfirm"
        run_cmd "pacman -S --needed --noconfirm linux-lts"
        ensure_grub_defaults_saved
        run_cmd "grub-mkconfig -o ${GRUB_CONFIG_PATH}"
        run_cmd "grub-set-default \"${GRUB_LTS_ENTRY}\""
    }; then
        log_error "$(red "linux-lts installation failed; please review ${LOG_FILE}")"
        exit 1
    fi

    saved_entry=$(grub-editenv list 2>/dev/null | awk -F= '/^saved_entry=/{print $2}' || true)
    if [[ "${saved_entry}" != "${GRUB_LTS_ENTRY}" ]]; then
        log_error "Expected GRUB saved_entry '${GRUB_LTS_ENTRY}', but grub-editenv reported '${saved_entry:-<unset>}'"
        exit 1
    fi

    record_pending_args "$@"
    write_continue_service
    local resume_cmd="${INSTALL_BIN} --resume $(cat ${PENDING_ARGS_FILE})"
    log_warn "$(yellow "Reboot required: linux-lts installed and set as default. Rebooting will auto-resume hardening via systemd.")"
    log_info "Manual resume command: ${resume_cmd}"
    log_info "$(green "LTS kernel installed. Rebooting in 5 seconds...")"
    sleep 5
    run_cmd "reboot"
}

ensure_ssh_group() {
    if getent group ssh >/dev/null 2>&1; then
        local current_gid
        current_gid=$(getent group ssh | cut -d: -f3)
        if (( current_gid < 1000 )); then
            log_info "SSH access group 'ssh' already exists as a system group (gid ${current_gid})"
            return
        fi

        local new_gid
        if ! new_gid=$(next_available_system_gid); then
            log_error "Unable to find a free system gid (<1000) to convert 'ssh' group"
            exit 1
        fi

        run_cmd "groupmod -g ${new_gid} ssh"
        log_warn "Converted existing 'ssh' group to system gid ${new_gid}"
        return
    fi

    run_cmd "groupadd -r ssh"
    log_info "Created system group 'ssh' for SSH access control"
}

ensure_user_in_group() {
    local user="$1" group="$2"
    if ! id -u "${user}" >/dev/null 2>&1; then
        if [[ ${DRY_RUN} -eq 1 ]]; then
            log_info "[DRY-RUN] Would ensure ${user} is in group ${group}"
            return
        fi
        log_error "User ${user} does not exist; cannot add to ${group}"
        exit 1
    fi
    if id -nG "${user}" | tr ' ' '\n' | grep -qx "${group}"; then
        return
    fi
    run_cmd "usermod -aG ${group} ${user}"
    log_info "Added ${user} to ${group}"
}

error_trap() {
    local exit_code=$?
    local cmd=${BASH_COMMAND}
    local src=${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}
    local line=${BASH_LINENO[0]:-0}
    log_error "Command failed with exit ${exit_code} at ${src}:${line}: ${cmd}"
    log_error "See ${LOG_FILE} for details."
    exit ${exit_code}
}
trap 'error_trap' ERR

switch_to_phase1_logging() {
    if [[ "${CURRENT_PHASE}" == "phase1" ]]; then
        return
    fi
    CURRENT_PHASE="phase1"
    LOG_FILE="${PHASE1_LOG}"
    export LOG_FILE
    log_info "==== Starting Phase 1 actions (logging to ${LOG_FILE}) ===="
}

run_as_user() {
    local user="$1"; shift
    local cmd="$*"
    local uid runtime_dir
    uid=$(id -u "${user}")
    runtime_dir="/run/user/${uid}"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] (as ${user}) ${cmd}"
        return 0
    fi
    run_cmd "install -d -m 0700 -o ${user} -g ${user} ${runtime_dir}"
    log_info "Running as ${user}: ${cmd}"
    set +e
    HOME=$(eval echo "~${user}") XDG_RUNTIME_DIR="${runtime_dir}" runuser -l "${user}" -c "${cmd}"
    local rc=$?
    set -e
    return ${rc}
}

user_systemctl() {
    local user="$1"; shift
    run_as_user "${user}" "systemctl --user $*"
}

final_summary() {
    log_info "==== âœ… Hardening completed ===="
    local summary output_dir
    summary=$(
        cat <<EOF
âœ… Hardening completed successfully.
$( (( ENABLE_FIREWALL )) && echo "ðŸ”’ Firewall: configured (ufw)" || echo "ðŸ”“ Firewall: skipped")
$( (( ENABLE_FAIL2BAN )) && echo "ðŸ›¡ï¸ Fail2ban: enabled" || echo "ðŸ›¡ï¸ Fail2ban: skipped")
ðŸ§ Kernel: $(uname -r)
ðŸ“¦ Packages updated and installed.
ðŸ§° Templates installed to /usr/share/vps-harden/templates/containers
ðŸ“œ Log: ${LOG_FILE}
EOF
    )
    if [[ -n "${USER_NAME}" ]] && id -u "${USER_NAME}" >/dev/null 2>&1; then
        output_dir="/home/${USER_NAME}"
    else
        output_dir="/root"
    fi
    FINAL_LOG_FILE="${output_dir}/vps-harden.log"
    echo "${summary}" > "${FINAL_LOG_FILE}"
    if [[ -n "${USER_NAME}" ]] && id -u "${USER_NAME}" >/dev/null 2>&1; then
        chown "${USER_NAME}:${USER_NAME}" "${FINAL_LOG_FILE}"
    fi
    log_info "Summary written to ${FINAL_LOG_FILE}"
}

install_packages() {
    local pkgs=()
    while IFS= read -r pkg; do
        pkgs+=("${pkg}")
    done < <(read_packages_from_file "${CONFIG_DIR}/packages.list")

    if [[ ${ENABLE_AUDITD} -eq 1 ]]; then
        while IFS= read -r pkg; do
            pkgs+=("${pkg}")
        done < <(read_packages_from_file "${CONFIG_DIR}/packages.auditd.list" 1)
    fi

    while IFS= read -r pkg; do
        pkgs+=("${pkg}")
    done < <(read_packages_from_file "${CONFIG_DIR}/packages.custom.list" 1)

    apply_package_replacements pkgs

    if [[ ${#pkgs[@]} -eq 0 ]]; then
        log_warn "No packages defined for installation; skipping package installation"
        return
    fi

    log_info "Updating system and installing packages: ${pkgs[*]}"
    run_cmd "pacman -Syu --noconfirm ${pkgs[*]}"
}

install_self() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would install archarden to ${INSTALL_PREFIX} and symlink to ${INSTALL_BIN}"
        return
    fi
    if [[ "${SCRIPT_DIR}" != "${INSTALL_PREFIX}" ]]; then
        mkdir -p "${INSTALL_PREFIX}"
        run_cmd "cp -a ${SCRIPT_DIR}/. ${INSTALL_PREFIX}/"
    fi
    run_cmd "install -m 0755 ${INSTALL_PREFIX}/harden ${INSTALL_BIN}"
}

next_available_system_gid() {
    local gid used
    mapfile -t used < <(getent group | awk -F: '{print $3}')
    for gid in $(seq 999 -1 100); do
        if ! printf '%s\n' "${used[@]}" | grep -qx "${gid}"; then
            echo "${gid}"
            return 0
        fi
    done
    return 1
}

resume_needs_restore() {
    local arg resume_present=0
    for arg in "$@"; do
        if [[ "${arg}" == "--resume" ]]; then
            resume_present=1
            break
        fi
    done
    if [[ ${resume_present} -eq 1 && $# -eq 1 ]]; then
        return 0
    fi
    return 1
}

parse_args() {
    RESUME_MODE=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --hostname) SYSTEM_HOSTNAME="$2"; shift 2;;
            --user) USER_NAME="$2"; shift 2;;
            --pubkey-file) PUBKEY_FILE="$2"; shift 2;;
            --pubkey) PUBKEY_VALUE="$2"; shift 2;;
            --version) show_version; exit 0;;
            --ssh-port) SSH_PORT="$2"; shift 2;;
            --restrict-ssh-cidr) RESTRICT_SSH_CIDR="$2"; shift 2;;
            --keep-ssh-22) KEEP_SSH_22=1; shift;;
            --enable-auditd) ENABLE_AUDITD=1; shift;;
            --disable-fail2ban) ENABLE_FAIL2BAN=0; shift;;
            --disable-firewall|--disable-ufw) ENABLE_FIREWALL=0; shift;;
            --disable-linger) ENABLE_LINGER=0; shift;;
            --skip-firewall-enable) SKIP_FIREWALL_ENABLE=1; shift;;
            --dry-run) DRY_RUN=1; shift;;
            --non-interactive) NON_INTERACTIVE=1; shift;;
            --resume) RESUME_MODE=1; shift;;
            -h|--help) usage; exit 0;;
            *) log_error "Unknown option: $1"; usage; exit 1;;
        esac
    done
    export DRY_RUN
}

preflight() {
    require_root
    if [[ -z "${SYSTEM_HOSTNAME}" ]]; then
        log_error "--hostname is required."
        exit 1
    fi
    if [[ -z "${USER_NAME}" ]]; then
        log_error "--user is required."
        exit 1
    fi
    if [[ -z "${PUBKEY_FILE}" && -z "${PUBKEY_VALUE}" ]]; then
        log_error "Either --pubkey-file or --pubkey is required."
        exit 1
    fi
    if ! grep -qi 'arch' /etc/os-release; then
        log_error "This tool is intended for Arch Linux systems."
        exit 1
    fi
    if [[ ${NON_INTERACTIVE} -eq 1 ]] && [[ -n "${USER_NAME}" ]] && [[ -z "${PUBKEY_FILE}" && -z "${PUBKEY_VALUE}" ]]; then
        log_error "--non-interactive requires --pubkey or --pubkey-file when creating a user."
        exit 1
    fi
    if ! [[ ${SSH_PORT} =~ ^[0-9]+$ ]] || (( SSH_PORT < 1 || SSH_PORT > 65535 )); then
        log_error "Invalid --ssh-port '${SSH_PORT}'. Must be 1-65535."
        exit 1
    fi
    if [[ -n "${SSH_CONNECTION:-}" ]]; then
        SSH_CONNECTION_INFO=${SSH_CONNECTION}
        log_info "Running under SSH from ${SSH_CONNECTION_INFO}"
    else
        log_warn "Not running under SSH; lockout protections limited."
    fi
}

read_packages_from_file() {
    local file="$1" optional="${2:-0}"
    if [[ ! -f "${file}" ]]; then
        if [[ "${optional}" -eq 1 ]]; then
            log_warn "Optional package list not found: ${file}; skipping"
            return
        fi
        log_error "Required package list not found: ${file}"
        exit 1
    fi

    grep -Ev '^[[:space:]]*(#|$)' "${file}"
}

apply_package_replacements() {
    local packages_var="$1"
    local -n packages_ref=${packages_var}
    local replacements_file="${CONFIG_DIR}/packages.replacements.list"
    local -a replacements=()

    while IFS= read -r line; do
        replacements+=("${line}")
    done < <(read_packages_from_file "${replacements_file}" 1)

    if [[ ${#replacements[@]} -eq 0 ]]; then
        return
    fi

    local entry current replacement
    for entry in "${replacements[@]}"; do
        read -r current replacement <<<"${entry}"
        if [[ -z "${current}" || -z "${replacement}" ]]; then
            log_warn "Skipping malformed replacement entry: ${entry}"
            continue
        fi
        if ! package_requested "${replacement}" "${packages_var}"; then
            continue
        fi
        if package_installed "${current}"; then
            replace_package "${current}" "${replacement}"
        fi
    done
}

package_requested() {
    local target="$1"
    local -n packages_ref=$2
    local pkg
    for pkg in "${packages_ref[@]}"; do
        if [[ "${pkg}" == "${target}" ]]; then
            return 0
        fi
    done
    return 1
}

package_installed() {
    local pkg="$1"
    if command -v pacman >/dev/null 2>&1; then
        pacman -Q "${pkg}" >/dev/null 2>&1
        return $?
    fi
    log_error "Unsupported package manager; cannot check installation state for ${pkg}"
    exit 1
}

replace_package() {
    local current="$1" replacement="$2"
    if command -v pacman >/dev/null 2>&1; then
        log_info "Replacing installed package ${current} with ${replacement}"
        if ! run_cmd "pacman -S --noconfirm --needed ${replacement}"; then
            log_warn "Direct install failed; retrying by removing ${current} first"
            run_cmd "pacman -Rdd --noconfirm ${current}"
            run_cmd "pacman -S --noconfirm --needed ${replacement}"
        fi
        return
    fi
    log_error "Unsupported package manager; cannot replace ${current} with ${replacement}"
    exit 1
}

record_pending_args() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would record pending args to ${PENDING_ARGS_FILE}: $*"
        return
    fi
    mkdir -p "${STATE_DIR}"
    printf '%q ' "$@" > "${PENDING_ARGS_FILE}"
    echo >> "${PENDING_ARGS_FILE}"
}

report_services() {
    log_info "Enabled services summary:"
    status_cmd "systemctl list-unit-files --type=service --state=enabled"
}

disable_units_from_config() {
    local list_file="${CONFIG_DIR}/disable-units.list"
    if [[ ! -f "${list_file}" ]]; then
        log_warn "Disable list missing at ${list_file}; skipping"
        return
    fi

    while IFS= read -r unit || [[ -n "${unit}" ]]; do
        unit=$(echo "${unit%%#*}" | sed -E 's/^[[:space:]]+//;s/[[:space:]]+$//')
        if [[ -z "${unit}" ]]; then
            continue
        fi
        if [[ "${unit}" == *cloud-init* ]]; then
            log_warn "Skipping cloud-init unit ${unit}"
            continue
        fi
        if systemctl is-enabled --quiet "${unit}" 2>/dev/null; then
            if ! run_cmd "systemctl disable --now ${unit}"; then
                log_warn "Failed to disable ${unit}; please review manually"
            fi
        fi
    done < "${list_file}"
}

ensure_default_target() {
    run_cmd "systemctl set-default multi-user.target"
    run_cmd "systemctl get-default"
}

verify_podman_runtime() {
    local uid runtime_dir runtime_output
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would verify Podman runtime as ${USER_NAME}"
        return
    fi
    uid=$(id -u "${USER_NAME}")
    runtime_dir="/run/user/${uid}"
    run_cmd "install -d -m 0700 -o ${USER_NAME} -g ${USER_NAME} ${runtime_dir}"
    runtime_output=$(HOME=$(eval echo "~${USER_NAME}") XDG_RUNTIME_DIR="${runtime_dir}" runuser -l "${USER_NAME}" -c "podman info --format '{{.Host.OCIRuntime.Name}}'" 2>/dev/null || true)
    runtime_output=$(echo "${runtime_output}" | tr -d '\r')
    if [[ "${runtime_output}" != "runc" ]]; then
        log_warn "Podman runtime reported '${runtime_output:-<empty>}' for ${USER_NAME}; expected 'runc'. Ensure containers.conf is applied."
    else
        log_info "Podman runtime verified as '${runtime_output}' for ${USER_NAME}"
    fi
}

verify_zram_swap() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would verify zram swap priority"
        return
    fi
    local swap_output zram_priority swapfile_priority
    swap_output=$(swapon --show --noheadings --raw --bytes 2>/dev/null || true)
    if [[ -z "${swap_output}" ]]; then
        log_warn "No active swap devices reported; zram may not be active."
        return
    fi
    zram_priority=$(echo "${swap_output}" | awk '$1 ~ /zram0/ {print $4}' | head -n1)
    swapfile_priority=$(echo "${swap_output}" | awk '$1 ~ /swapfile/ {print $4}' | head -n1)
    if echo "${swap_output}" | grep -q '/dev/zram0'; then
        log_info "zram device detected in swap list."
    else
        log_warn "zram device /dev/zram0 not present in swap list."
    fi
    if [[ -n "${zram_priority}" && -n "${swapfile_priority}" ]]; then
        if (( zram_priority > swapfile_priority )); then
            log_info "zram priority (${zram_priority}) is higher than swapfile (${swapfile_priority})."
        else
            log_warn "zram priority (${zram_priority:-unset}) is not higher than swapfile (${swapfile_priority:-unset})."
        fi
    else
        log_warn "Could not determine swap priorities for zram and swapfile; review swapon output manually."
    fi
}

restart_sshd_and_verify() {
    if [ "${DRY_RUN}" -eq 0 ]; then
        run_cmd "systemctl restart sshd"
        if ! ss -tulpn | grep -q ":${SSH_PORT}"; then
            log_error "sshd is not listening on port ${SSH_PORT} after restart"
            exit 1
        fi
    else
        log_info "[DRY-RUN] Would restart sshd and verify port ${SSH_PORT}"
    fi
}

status_cmd() {
    local cmd="$*"
    log_info "Status: ${cmd}"
    eval "${cmd}"
}

status_report() {
    log_info "==== STATUS REPORT ===="
    status_cmd "ss -tulnp || true"
    if command -v ufw >/dev/null 2>&1; then
        status_cmd "ufw status verbose || true"
    fi
    if systemctl list-unit-files --type=service | grep -q fail2ban.service; then
        status_cmd "systemctl status fail2ban --no-pager || true"
    fi
    report_services
    if [[ ${#BACKUP_PATHS[@]} -gt 0 ]]; then
        log_info "Backups created: ${BACKUP_PATHS[*]}"
    fi
}

usage() {
    printf "%s\n" "$(bold "Usage:") $(cyan "sudo ./harden [options]")"
    printf "  %s\n" "$(cyan "--hostname <name>")        Set the system hostname."
    printf "  %s\n" "$(cyan "--user <name>")            Create or ensure admin user exists and in wheel group."
    printf "  %s\n" "$(cyan "--pubkey-file <path>")     Public key file to install for the admin user."
    printf "  %s\n" "$(cyan "--pubkey \"<key>\"")         Public key string to install for the admin user."
    printf "  %s\n" "$(cyan "--version")                Show version and exit."
    printf "  %s\n" "$(cyan "--ssh-port <port>")        SSH port to configure (default: 2122)."
    printf "  %s\n" "$(cyan "--restrict-ssh-cidr <C>")  Restrict SSH via UFW to the given CIDR."
    printf "  %s\n" "$(cyan "--keep-ssh-22")            Keep SSH port 22 allowed (transition)."
    printf "  %s\n" "$(cyan "--enable-auditd")          Install and enable auditd."
    printf "  %s\n" "$(cyan "--disable-fail2ban")       Skip fail2ban configuration."
    printf "  %s\n" "$(cyan "--disable-firewall")       Skip firewall configuration (alias: --disable-ufw)."
    printf "  %s\n" "$(cyan "--disable-linger")         Disable lingering for the admin user."
    printf "  %s\n" "$(cyan "--skip-firewall-enable")   Write UFW rules but do not enable the firewall."
    printf "  %s\n" "$(cyan "--dry-run")                Show actions without changing the system."
    printf "  %s\n" "$(cyan "--non-interactive")        Fail if required inputs are missing instead of prompting."
    printf "  %s\n" "$(cyan "--resume")                 Internal flag: resume after reboot; do not re-arm continuation."
    printf "  %s\n" "$(cyan "-h, --help")               Show this help."
}

verify_nf_tables_after_reboot() {
    if [[ ${RESUME_MODE} -eq 0 ]]; then
        return
    fi
    status_cmd "lsmod | grep -E 'nf_tables|nfnetlink' || true"
}

write_continue_service() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would install continuation service at ${CONTINUE_SERVICE}"
        return
    fi
    render_template "${CONTINUE_SERVICE_TEMPLATE}" "${CONTINUE_SERVICE}" \
        "PENDING_ARGS_FILE=${PENDING_ARGS_FILE}" \
        "INSTALL_PREFIX=${INSTALL_PREFIX}"
    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable vps-harden-continue.service"
}

show_version() {
    local version_file="${SCRIPT_DIR}/VERSION"
    if [[ -f "${version_file}" ]]; then
        cat "${version_file}"
    else
        echo "unknown"
    fi
}

main() {
    if resume_needs_restore "$@"; then
        if [[ ! -s "${PENDING_ARGS_FILE}" ]]; then
            log_error "Resume requested but pending args missing at ${PENDING_ARGS_FILE}"
            exit 1
        fi
        local saved_args
        saved_args=$(cat "${PENDING_ARGS_FILE}")
        log_info "Resume requested without parameters; restoring saved arguments from ${PENDING_ARGS_FILE}"
        eval "set -- --resume ${saved_args}"
    fi

    parse_args "$@"
    preflight
    install_self
    clear_pending_state
    ensure_lts_kernel_and_reboot_gate "$@"
    switch_to_phase1_logging
    verify_nf_tables_after_reboot
    install_packages
    enable_timesync
    configure_journald
    configure_sysctl
    configure_vm_tuning_sysctl
    apply_sysctl_settings
    configure_tmp_mount
    configure_zram
    configure_hostname
    ensure_ssh_group
    create_admin_user
    configure_podman_runtime
    configure_sshd
    restart_sshd_and_verify
    configure_ufw
    configure_fail2ban
    configure_podman_templates
    configure_rootless_quadlets
    configure_socket_proxyd
    verify_podman_runtime
    verify_zram_swap
    ensure_default_target
    disable_units_from_config
    status_report
    final_summary
}

main "$@"

show_version() {
    local version_file="${SCRIPT_DIR}/VERSION"
    if [[ -f "${version_file}" ]]; then
        cat "${version_file}"
    else
        echo "unknown"
    fi
}
