#!/usr/bin/env bash
# SPDX-License-Identifier: AGPL-3.0-or-later
# Copyright (c) 2025 Richard Majewski
set -eEuo pipefail

PHASE0_LOG="/var/log/vps-harden.phase0.log"
PHASE1_LOG="/var/log/vps-harden.phase1.log"
LOG_FILE="${PHASE0_LOG}"
CURRENT_PHASE="phase0"
SSHD_CONFIG_DIR="/etc/ssh/sshd_config.d"
SSHD_HARDENING_DROPIN="${SSHD_CONFIG_DIR}/10-hardening.conf"
SSHD_CRYPTO_DROPIN="${SSHD_CONFIG_DIR}/10-crypto-hardening.conf"
SSH_HOSTKEY_BACKUP_BASE="/root/ssh-hostkey-backup"
for arg in "$@"; do
    if [[ "${arg}" == "--resume" ]]; then
        LOG_FILE="${PHASE1_LOG}"
        CURRENT_PHASE="phase1"
        break
    fi
done

DEFAULT_INSTALL_PREFIX="/usr/local/lib/vps-harden"
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
if [[ ! -f "${SCRIPT_DIR}/lib/utils.sh" ]]; then
    FALLBACK_DIR="${DEFAULT_INSTALL_PREFIX}"
    if [[ -f "${FALLBACK_DIR}/lib/utils.sh" ]]; then
        SCRIPT_DIR="${FALLBACK_DIR}"
    else
        printf 'Required helper not found: %s\n' "${SCRIPT_DIR}/lib/utils.sh" >&2
        exit 1
    fi
fi
CONFIG_DIR="${SCRIPT_DIR}/config"
TEMPLATES_DIR="${SCRIPT_DIR}/templates"
source "${SCRIPT_DIR}/lib/utils.sh"

DRY_RUN=0
ENABLE_FAIL2BAN=1
ENABLE_FIREWALL=1
SKIP_FIREWALL_ENABLE=0
KEEP_SSH_22=0
RESTRICT_SSH_CIDR=""
USER_NAME=""
USER_HOME=""
PODMAN_USER="podmin"
PODMAN_HOME=""
PODMAN_UID=""
ENSURED_PODMIN_MANAGER=0
PUBKEY_FILE=""
PUBKEY_VALUE=""
ENABLE_AUDITD=0
SYSTEM_HOSTNAME=""
SSH_PORT=2122
SSH_CONNECTION_INFO=""
GRUB_LTS_ENTRY="Advanced options for Arch Linux>Arch Linux, with Linux linux-lts"
GRUB_CONFIG_PATH="/boot/grub/grub.cfg"
INSTALL_PREFIX="${DEFAULT_INSTALL_PREFIX}"
INSTALL_BIN="/usr/local/bin/vps-harden"
STATE_DIR="/var/lib/vps-harden"
PENDING_ARGS_FILE="${STATE_DIR}/pending_args"
PERSISTED_PUBKEY_FILE="${STATE_DIR}/pubkey"
CONTINUE_SERVICE="/etc/systemd/system/vps-harden-continue.service"
CONTINUE_SERVICE_TEMPLATE="${TEMPLATES_DIR}/systemd/vps-harden-continue.service"
FINAL_LOG_FILE=""

clear_pending_state() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would clear pending state at ${PENDING_ARGS_FILE}"
        return
    fi
    rm -f "${PENDING_ARGS_FILE}"
}

ensure_fail2ban_sshd_local() {
    local target=/etc/fail2ban/jail.d/sshd.local
    local tmp_base tmp_other tmp_out current_section section_lower

    tmp_base=$(mktemp)
    tmp_other=$(mktemp)
    tmp_out=$(mktemp)

    sed "s/__SSH_PORT__/${SSH_PORT}/g" "${CONFIG_DIR}/fail2ban_sshd.local" > "${tmp_base}"

    if [[ -f "${target}" ]]; then
        current_section=""
        while IFS= read -r line || [[ -n "${line}" ]]; do
            if [[ "${line}" =~ ^\[([^]]+)\] ]]; then
                current_section="${BASH_REMATCH[1]}"
            fi
            section_lower=${current_section,,}
            if [[ "${section_lower}" != "default" && "${section_lower}" != "sshd" ]]; then
                echo "${line}" >>"${tmp_other}"
            fi
        done < "${target}"
    fi

    cat "${tmp_base}" > "${tmp_out}"
    if [[ -s "${tmp_other}" ]]; then
        echo >>"${tmp_out}"
        cat "${tmp_other}" >>"${tmp_out}"
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_base}" "${tmp_other}" "${tmp_out}"
    run_cmd "chown root:root ${target}"
}

ensure_fail2ban_defaults_local() {
    local target=/etc/fail2ban/jail.local
    local tmp_base tmp_other tmp_out current_section section_lower

    tmp_base=$(mktemp)
    tmp_other=$(mktemp)
    tmp_out=$(mktemp)

    cat "${CONFIG_DIR}/fail2ban_jail.local" > "${tmp_base}"

    if [[ -f "${target}" ]]; then
        current_section=""
        while IFS= read -r line || [[ -n "${line}" ]]; do
            if [[ "${line}" =~ ^\[([^]]+)\] ]]; then
                current_section="${BASH_REMATCH[1]}"
            fi
            section_lower=${current_section,,}
            if [[ "${section_lower}" != "default" ]]; then
                echo "${line}" >>"${tmp_other}"
            fi
        done < "${target}"
    fi

    cat "${tmp_base}" > "${tmp_out}"
    if [[ -s "${tmp_other}" ]]; then
        echo >>"${tmp_out}"
        cat "${tmp_other}" >>"${tmp_out}"
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_base}" "${tmp_other}" "${tmp_out}"
    run_cmd "chown root:root ${target}"
}

run_status_capture() {
    local label="$1"; shift
    local err_file output rc err_msg
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would run: $*"
        return 0
    fi
    err_file=$(mktemp)
    set +e
    output=$("$@" 2>"${err_file}")
    rc=$?
    set -e
    if [[ ${rc} -ne 0 ]]; then
        err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
        log_warn "${label} failed: ${err_msg:-unknown}"
    else
        while IFS= read -r line || [[ -n "${line}" ]]; do
            log_info "${label}: ${line}"
        done <<<"${output:-ok}"
    fi
    rm -f "${err_file}"
}

configure_fail2ban() {
    if [[ ${ENABLE_FAIL2BAN} -eq 0 ]]; then
        log_warn "Fail2ban disabled by flag"
        return
    fi
    backup_file /etc/fail2ban/jail.local
    backup_file /etc/fail2ban/jail.d/sshd.local
    run_cmd "install -d -m 0755 /etc/fail2ban/jail.d"
    ensure_fail2ban_defaults_local
    ensure_fail2ban_sshd_local
    run_cmd "systemctl enable --now fail2ban.service"
    run_cmd "systemctl restart fail2ban.service"
    if command -v ufw >/dev/null 2>&1; then
        if ! ufw status 2>/dev/null | grep -qi "Status: active"; then
            log_warn "ufw is not active; banaction=ufw will not take effect until ufw is enabled"
        else
            run_status_capture "ufw status numbered" ufw status numbered
        fi
    fi
    run_status_capture "fail2ban-client status" fail2ban-client status
    run_status_capture "fail2ban-client status sshd" fail2ban-client status sshd
}

configure_hostname() {
    if [[ -z "${SYSTEM_HOSTNAME}" ]]; then
        return
    fi
    run_cmd "hostnamectl set-hostname ${SYSTEM_HOSTNAME}"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        return
    fi
    log_info "Hostname set to ${SYSTEM_HOSTNAME}"
}

configure_journald() {
    backup_file /etc/systemd/journald.conf
    write_file_atomic /etc/systemd/journald.conf < "${CONFIG_DIR}/journald.conf"
    run_cmd "systemctl restart systemd-journald"
}

configure_podman_templates() {
    local dest_dir=/usr/share/vps-harden/templates/containers
    write_file_atomic /usr/share/vps-harden/README <<'EOT'
Podman templates installed by vps-harden.
EOT
    write_file_atomic "${dest_dir}/nginx-proxy-manager.container" < "${TEMPLATES_DIR}/containers/nginx-proxy-manager.container"
    write_file_atomic "${dest_dir}/podman-run-npm.sh" < "${TEMPLATES_DIR}/containers/podman-run-npm.sh"
    write_file_atomic "${dest_dir}/gotify.container" < "${TEMPLATES_DIR}/containers/gotify.container"
    write_file_atomic "${dest_dir}/podman-run-gotify.sh" < "${TEMPLATES_DIR}/containers/podman-run-gotify.sh"
    run_cmd "chmod +x ${dest_dir}/podman-run-npm.sh"
    run_cmd "chmod +x ${dest_dir}/podman-run-gotify.sh"
}

ensure_containers_runtime_config() {
    local target="$1" owner="${2:-root}" group="${3:-root}"
    local runtime_line='runtime = "runc"'
    local tmp in_engine=0 runtime_set=0 found_engine=0
    tmp=$(mktemp)

    run_cmd "install -d -m 0755 -o ${owner} -g ${group} $(dirname "${target}")"

    if [[ -f "${target}" ]]; then
        while IFS= read -r line || [[ -n "${line}" ]]; do
            if [[ "${line}" =~ ^\[.*\] ]]; then
                if [[ ${in_engine} -eq 1 && ${runtime_set} -eq 0 ]]; then
                    echo "${runtime_line}" >>"${tmp}"
                fi
                in_engine=0
            fi
            if [[ "${line}" =~ ^\[engine\] ]]; then
                found_engine=1
                in_engine=1
                runtime_set=0
            fi
            if [[ ${in_engine} -eq 1 && "${line}" =~ ^runtime[[:space:]]*= ]]; then
                line=${runtime_line}
                runtime_set=1
            fi
            echo "${line}" >>"${tmp}"
        done < "${target}"
    fi

    if [[ ${in_engine} -eq 1 && ${runtime_set} -eq 0 ]]; then
        echo "${runtime_line}" >>"${tmp}"
    fi

    if [[ ${found_engine} -eq 0 ]]; then
        [[ -s "${tmp}" ]] && echo >>"${tmp}"
        {
            echo "[engine]"
            echo "${runtime_line}"
        } >>"${tmp}"
    fi

    write_file_atomic "${target}" < "${tmp}"
    rm -f "${tmp}"
    if [[ "${owner}" != "root" || "${group}" != "root" ]]; then
        run_cmd "chown ${owner}:${group} ${target}"
    fi
}

configure_podman_runtime() {
    local podmin_home
    podmin_home="${PODMAN_HOME:-$(getent passwd "${PODMAN_USER}" | cut -d: -f6)}"
    if [[ -z "${podmin_home}" ]]; then
        if [[ ${DRY_RUN} -eq 1 ]]; then
            podmin_home="/home/${PODMAN_USER}"
        else
            log_error "Unable to determine home for ${PODMAN_USER}"
            exit 1
        fi
    fi
    ensure_containers_runtime_config /etc/containers/containers.conf root root
    ensure_containers_runtime_config "${podmin_home}/.config/containers/containers.conf" "${PODMAN_USER}" "${PODMAN_USER}"
}

ensure_npm_quadlet() {
    local user_home systemd_dir target input tmp_out
    user_home="${PODMAN_HOME:-$(getent passwd "${PODMAN_USER}" | cut -d: -f6)}"
    if [[ -z "${user_home}" ]]; then
        log_error "Unable to determine home for ${PODMAN_USER}"
        exit 1
    fi
    systemd_dir="${user_home}/.config/containers/systemd"
    target="${systemd_dir}/nginx-proxy-manager.container"
    input="${target}"
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${user_home}/.config ${user_home}/.config/containers ${systemd_dir}"
    if [[ ! -f "${input}" ]]; then
        input="${TEMPLATES_DIR}/containers/nginx-proxy-manager.container"
    fi

    tmp_out=$(mktemp)
    local in_container=0 saw_memory=0 saw_pids=0 saw_podmanargs=0
    local in_install=0 saw_install=0 saw_install_wanted_by=0 saw_install_default_target=0
    local -a required_ports=("127.0.0.1:8181:81" "127.0.0.1:8080:80" "127.0.0.1:8443:443")
    declare -A port_seen
    for port in "${required_ports[@]}"; do
        port_seen["${port}"]=0
    done

    while IFS= read -r line || [[ -n "${line}" ]]; do
        if [[ "${line}" =~ ^\[.*\] ]]; then
            if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
                echo "WantedBy=default.target" >>"${tmp_out}"
                saw_install_default_target=1
            fi
            if [[ ${in_container} -eq 1 ]]; then
                for port in "${required_ports[@]}"; do
                    if [[ ${port_seen[${port}]} -eq 0 ]]; then
                        echo "PublishPort=${port}" >>"${tmp_out}"
                        port_seen["${port}"]=1
                    fi
                done
                if [[ ${saw_memory} -eq 0 ]]; then
                    echo "Memory=512M" >>"${tmp_out}"
                fi
                if [[ ${saw_pids} -eq 0 ]]; then
                    echo "PidsLimit=512" >>"${tmp_out}"
                fi
                if [[ ${saw_podmanargs} -eq 0 ]]; then
                    echo "PodmanArgs=--memory-swap=1G" >>"${tmp_out}"
                fi
            fi
            in_container=0
            in_install=0
        fi

        if [[ "${line}" =~ ^\[Install\]$ ]]; then
            in_install=1
            saw_install=1
            saw_install_wanted_by=0
        fi

        if [[ ${in_container} -eq 1 ]]; then
            if [[ "${line}" =~ ^PublishPort= ]]; then
                local port_value
                port_value=${line#PublishPort=}
                if [[ "${port_value}" == "80:80" || "${port_value}" == "443:443" ]]; then
                    continue
                fi
                if [[ -n "${port_seen[${port_value}]+x}" ]]; then
                    if [[ ${port_seen[${port_value}]} -eq 1 ]]; then
                        continue
                    fi
                    port_seen["${port_value}"]=1
                fi
                echo "PublishPort=${port_value}" >>"${tmp_out}"
                continue
            fi

            if [[ "${line}" =~ ^Memory= ]]; then
                if [[ ${saw_memory} -eq 1 ]]; then
                    continue
                fi
                line="Memory=512M"
                saw_memory=1
            fi
            if [[ "${line}" =~ ^PidsLimit= ]]; then
                if [[ ${saw_pids} -eq 1 ]]; then
                    continue
                fi
                line="PidsLimit=512"
                saw_pids=1
            fi
            if [[ "${line}" =~ ^Network= ]]; then
                if [[ "${line}" == "Network=host" ]]; then
                    line="Network=slirp4netns"
                fi
            fi
            if [[ "${line}" =~ ^PodmanArgs= ]]; then
                if [[ ${saw_podmanargs} -eq 1 ]]; then
                    continue
                fi
                saw_podmanargs=1
                if [[ "${line}" != *"--memory-swap=1G"* ]]; then
                    line="${line} --memory-swap=1G"
                fi
            fi
        fi

        if [[ ${in_install} -eq 1 && "${line}" =~ ^WantedBy= ]]; then
            saw_install_wanted_by=1
            if [[ "${line#WantedBy=}" == *"default.target"* ]]; then
                saw_install_default_target=1
            fi
        fi

        echo "${line}" >>"${tmp_out}"

        if [[ "${line}" == "[Container]" ]]; then
            in_container=1
            saw_memory=0
            saw_pids=0
            saw_podmanargs=0
            for port in "${required_ports[@]}"; do
                port_seen["${port}"]=0
            done
        fi
    done < "${input}"

    if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    if [[ ${in_container} -eq 1 ]]; then
        for port in "${required_ports[@]}"; do
            if [[ ${port_seen[${port}]} -eq 0 ]]; then
                echo "PublishPort=${port}" >>"${tmp_out}"
            fi
        done
        if [[ ${saw_memory} -eq 0 ]]; then
            echo "Memory=512M" >>"${tmp_out}"
        fi
        if [[ ${saw_pids} -eq 0 ]]; then
            echo "PidsLimit=512" >>"${tmp_out}"
        fi
        if [[ ${saw_podmanargs} -eq 0 ]]; then
            echo "PodmanArgs=--memory-swap=1G" >>"${tmp_out}"
        fi
    fi

    if [[ ${saw_install} -eq 0 ]]; then
        echo >>"${tmp_out}"
        echo "[Install]" >>"${tmp_out}"
        echo "WantedBy=default.target" >>"${tmp_out}"
    elif [[ ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_out}"
    run_cmd "chown ${PODMAN_USER}:${PODMAN_USER} ${target}"
    run_cmd "chmod 0644 ${target}"
}

ensure_gotify_quadlet() {
    local user_home systemd_dir target input tmp_out
    user_home="${PODMAN_HOME:-$(getent passwd "${PODMAN_USER}" | cut -d: -f6)}"
    if [[ -z "${user_home}" ]]; then
        log_error "Unable to determine home for ${PODMAN_USER}"
        exit 1
    fi
    systemd_dir="${user_home}/.config/containers/systemd"
    target="${systemd_dir}/gotify.container"
    input="${target}"
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${user_home}/.config ${user_home}/.config/containers ${systemd_dir}"
    if [[ ! -f "${input}" ]]; then
        input="${TEMPLATES_DIR}/containers/gotify.container"
    fi

    tmp_out=$(mktemp)
    local in_container=0 saw_memory=0 saw_pids=0
    local in_install=0 saw_install=0 saw_install_wanted_by=0 saw_install_default_target=0

    while IFS= read -r line || [[ -n "${line}" ]]; do
        if [[ "${line}" =~ ^\[.*\] ]]; then
            if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
                echo "WantedBy=default.target" >>"${tmp_out}"
                saw_install_default_target=1
            fi
            if [[ ${in_container} -eq 1 ]]; then
                if [[ ${saw_memory} -eq 0 ]]; then
                    echo "Memory=128M" >>"${tmp_out}"
                fi
                if [[ ${saw_pids} -eq 0 ]]; then
                    echo "PidsLimit=256" >>"${tmp_out}"
                fi
            fi
            in_container=0
            in_install=0
        fi

        if [[ "${line}" =~ ^\[Install\]$ ]]; then
            in_install=1
            saw_install=1
            saw_install_wanted_by=0
        fi

        if [[ ${in_container} -eq 1 ]]; then
            if [[ "${line}" =~ ^Memory= ]]; then
                if [[ ${saw_memory} -eq 1 ]]; then
                    continue
                fi
                line="Memory=128M"
                saw_memory=1
            fi
            if [[ "${line}" =~ ^PidsLimit= ]]; then
                if [[ ${saw_pids} -eq 1 ]]; then
                    continue
                fi
                line="PidsLimit=256"
                saw_pids=1
            fi
        fi

        if [[ ${in_install} -eq 1 && "${line}" =~ ^WantedBy= ]]; then
            saw_install_wanted_by=1
            if [[ "${line#WantedBy=}" == *"default.target"* ]]; then
                saw_install_default_target=1
            fi
        fi

        echo "${line}" >>"${tmp_out}"

        if [[ "${line}" == "[Container]" ]]; then
            in_container=1
            saw_memory=0
            saw_pids=0
        fi
    done < "${input}"

    if [[ ${in_install} -eq 1 && ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    if [[ ${in_container} -eq 1 ]]; then
        if [[ ${saw_memory} -eq 0 ]]; then
            echo "Memory=128M" >>"${tmp_out}"
        fi
        if [[ ${saw_pids} -eq 0 ]]; then
            echo "PidsLimit=256" >>"${tmp_out}"
        fi
    fi

    if [[ ${saw_install} -eq 0 ]]; then
        echo >>"${tmp_out}"
        echo "[Install]" >>"${tmp_out}"
        echo "WantedBy=default.target" >>"${tmp_out}"
    elif [[ ${saw_install_default_target} -eq 0 ]]; then
        echo "WantedBy=default.target" >>"${tmp_out}"
        saw_install_default_target=1
    fi

    write_file_atomic "${target}" < "${tmp_out}"
    rm -f "${tmp_out}"
    run_cmd "chown ${PODMAN_USER}:${PODMAN_USER} ${target}"
    run_cmd "chmod 0644 ${target}"
}

verify_quadlet_status() {
    local service="$1"
    ensure_podmin_user_manager
    if podmin_systemctl status "${service}" --no-pager; then
        return 0
    fi
    log_warn "Status check failed for ${service}; inspecting generated units"
    run_cmd "systemctl --user --machine=${PODMAN_USER}@.host list-unit-files --no-pager | grep -E 'nginx-proxy-manager|gotify' || true"
    run_cmd "ls -la /run/user/${PODMAN_UID}/systemd/generator/ | grep -E 'nginx-proxy-manager|gotify' || true"
}

configure_rootless_quadlets() {
    ensure_npm_quadlet
    ensure_gotify_quadlet
    ensure_podmin_user_manager
    if ! podmin_systemctl daemon-reload; then
        log_warn "Failed to reload user systemd daemon for ${PODMAN_USER}; rootless services may not be active"
    fi
    if ! podmin_systemctl start nginx-proxy-manager.service; then
        log_warn "Failed to start nginx-proxy-manager.service for ${PODMAN_USER}; rootless services may not be active"
    else
        verify_quadlet_status nginx-proxy-manager.service
    fi
    if ! podmin_systemctl start gotify.service; then
        log_warn "Failed to start gotify.service for ${PODMAN_USER}; rootless services may not be active"
    else
        verify_quadlet_status gotify.service
    fi
}

configure_socket_proxyd() {
    local http_socket=/etc/systemd/system/archarden-http.socket
    local http_service=/etc/systemd/system/archarden-http.service
    local https_socket=/etc/systemd/system/archarden-https.socket
    local https_service=/etc/systemd/system/archarden-https.service

    backup_file "${http_socket}"
    backup_file "${http_service}"
    backup_file "${https_socket}"
    backup_file "${https_service}"

    write_file_atomic "${http_socket}" <<'EOT'
[Socket]
ListenStream=80
Accept=no

[Install]
WantedBy=sockets.target
EOT

    write_file_atomic "${http_service}" <<'EOT'
[Unit]
Requires=archarden-http.socket

[Service]
ExecStart=/usr/lib/systemd/systemd-socket-proxyd 127.0.0.1:8080
StandardInput=socket
EOT

    write_file_atomic "${https_socket}" <<'EOT'
[Socket]
ListenStream=443
Accept=no

[Install]
WantedBy=sockets.target
EOT

    write_file_atomic "${https_service}" <<'EOT'
[Unit]
Requires=archarden-https.socket

[Service]
ExecStart=/usr/lib/systemd/systemd-socket-proxyd 127.0.0.1:8443
StandardInput=socket
EOT

    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable --now archarden-http.socket archarden-https.socket"
}

configure_sshd() {
    mkdir -p "${SSHD_CONFIG_DIR}"
    run_cmd "ssh-keygen -A"
    backup_file "${SSHD_HARDENING_DROPIN}"
    backup_file "${SSHD_CRYPTO_DROPIN}"
    sed "s/__SSH_PORT__/${SSH_PORT}/g" "${CONFIG_DIR}/sshd_hardening.conf" | write_file_atomic "${SSHD_HARDENING_DROPIN}"
    write_file_atomic "${SSHD_CRYPTO_DROPIN}" < "${CONFIG_DIR}/sshd_crypto_hardening.conf"
    if [ "${DRY_RUN}" -eq 0 ]; then
        if ! sshd -t; then
            log_error "sshd configuration failed validation"
            restore_sshd_dropins
            exit 1
        fi
    else
        log_info "[DRY-RUN] Skipping sshd validation"
    fi
}

configure_sysctl() {
    backup_file /etc/sysctl.d/99-hardening.conf
    write_file_atomic /etc/sysctl.d/99-hardening.conf < "${CONFIG_DIR}/sysctl_hardening.conf"
}

configure_vm_tuning_sysctl() {
    local dest=/etc/sysctl.d/99-vm-tuning.conf
    backup_file "${dest}"
    write_file_atomic "${dest}" < "${CONFIG_DIR}/vm-tuning.conf"
}

apply_sysctl_settings() {
    run_cmd "sysctl --system"
}

configure_tmp_mount() {
    backup_file /etc/systemd/system/tmp.mount
    write_file_atomic /etc/systemd/system/tmp.mount < "${CONFIG_DIR}/tmp.mount"
    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable --now tmp.mount"
}

configure_zram() {
    local dest=/etc/systemd/zram-generator.conf
    backup_file "${dest}"
    write_file_atomic "${dest}" < "${CONFIG_DIR}/zram-generator.conf"
    run_cmd "systemctl daemon-reload"
    if ! run_cmd "systemctl restart systemd-zram-setup@zram0.service"; then
        log_warn "systemd-zram-setup@zram0.service not available; ensure zram-generator is installed and units exist."
    fi
}

configure_ufw() {
    if [[ ${ENABLE_FIREWALL} -eq 0 ]]; then
        log_warn "Firewall configuration disabled by flag"
        return
    fi
    ensure_firewall_backend

    if ! command -v ufw >/dev/null 2>&1; then
        log_error "ufw command not found; install the ufw package."
        exit 1
    fi

    backup_file /etc/default/ufw
    run_cmd "sed -i 's/^IPV6=.*/IPV6=yes/' /etc/default/ufw || echo 'IPV6=yes' >> /etc/default/ufw"
    run_cmd "ufw --force reset"
    run_cmd "ufw default deny incoming"
    run_cmd "ufw default allow outgoing"

    if ufw --version 2>/dev/null | grep -qi nftables; then
        log_info "UFW reports nftables backend"
    else
        log_warn "UFW backend is not reporting nftables; ensure iptables-nft is the active alternative."
    fi

    if [[ -n "${RESTRICT_SSH_CIDR}" ]]; then
        run_cmd "ufw allow from ${RESTRICT_SSH_CIDR} to any port ${SSH_PORT} proto tcp"
    else
        run_cmd "ufw limit ${SSH_PORT}/tcp"
    fi

    if ss -tulpn 2>/dev/null | grep -q ':22'; then
        run_cmd "ufw allow 22/tcp"
    fi
    if [[ ${KEEP_SSH_22} -eq 1 ]]; then
        run_cmd "ufw allow 22/tcp"
    fi

    local allowlist_entries=()
    while IFS= read -r port; do
        allowlist_entries+=("${port}")
    done < <(read_packages_from_file "${CONFIG_DIR}/firewall_allow.list" 1)

    if [[ ${#allowlist_entries[@]} -eq 0 ]]; then
        log_warn "No firewall allowlist entries defined; skipping port allows"
    else
        for port in "${allowlist_entries[@]}"; do
            run_cmd "ufw allow ${port}"
        done
    fi

    if [[ ${SKIP_FIREWALL_ENABLE} -eq 1 ]]; then
        log_warn "Skipping firewall enable as requested"
        return
    fi

    run_cmd "ufw --force enable"
    if [[ ${KEEP_SSH_22} -eq 0 ]]; then
        if [ "${DRY_RUN}" -eq 0 ]; then
            ufw delete allow 22/tcp >/dev/null 2>&1 || true
        else
            log_info "[DRY-RUN] Would remove legacy SSH port 22 rule"
        fi
    fi
    run_cmd "ufw reload"
}

ensure_admin_sudoers() {
    local sudoers_file=/etc/sudoers.d/90-archarden-ssh-user tmp
    tmp=$(mktemp)
    printf "%s ALL=(ALL) NOPASSWD: ALL\n" "${USER_NAME}" > "${tmp}"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would install sudoers entry at ${sudoers_file} for ${USER_NAME}"
        rm -f "${tmp}"
        return
    fi
    backup_file "${sudoers_file}"
    install -D -m 0440 "${tmp}" "${sudoers_file}"
    chown root:root "${sudoers_file}"
    rm -f "${tmp}"
}

create_admin_user() {
    if [[ -z "${USER_NAME}" ]]; then
        return
    fi
    if id -u "${USER_NAME}" >/dev/null 2>&1; then
        log_info "User ${USER_NAME} already exists"
    else
        run_cmd "useradd -m -G wheel,ssh -s /bin/bash ${USER_NAME}"
        log_info "Created user ${USER_NAME} and added to wheel,ssh"
    fi
    ensure_user_in_group "${USER_NAME}" wheel
    ensure_user_in_group "${USER_NAME}" ssh
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would lock password for ${USER_NAME}"
    else
        run_cmd "passwd -l ${USER_NAME}"
    fi
    USER_HOME=$(getent passwd "${USER_NAME}" | cut -d: -f6)
    if [[ -z "${USER_HOME}" ]]; then
        log_error "Unable to determine home for ${USER_NAME}"
        exit 1
    fi
    if [[ -n "${PUBKEY_FILE}" ]]; then
        PUBKEY_VALUE=$(cat "${PUBKEY_FILE}")
    fi
    if [[ -n "${PUBKEY_VALUE}" ]]; then
        local ssh_dir="${USER_HOME}/.ssh"
        run_cmd "install -d -m 700 -o ${USER_NAME} -g ${USER_NAME} ${ssh_dir}"
        local auth_keys="${ssh_dir}/authorized_keys"
        if [ "${DRY_RUN}" -eq 0 ]; then
            if [ ! -f "${auth_keys}" ]; then
                touch "${auth_keys}"
                chown "${USER_NAME}:${USER_NAME}" "${auth_keys}"
                chmod 600 "${auth_keys}"
            fi
            if ! grep -qxF "${PUBKEY_VALUE}" "${auth_keys}"; then
                echo "${PUBKEY_VALUE}" >>"${auth_keys}"
            fi
        else
            log_info "[DRY-RUN] Would add key for ${USER_NAME}"
        fi
    else
        log_warn "No public key provided for ${USER_NAME}; ensure key-based auth manually."
    fi

    ensure_admin_sudoers
}

ensure_podmin_user() {
    local expected_home="/home/${PODMAN_USER}" current_home current_shell
    if id -u "${PODMAN_USER}" >/dev/null 2>&1; then
        log_info "Podman runtime user ${PODMAN_USER} already exists"
        current_home=$(getent passwd "${PODMAN_USER}" | cut -d: -f6)
        current_shell=$(getent passwd "${PODMAN_USER}" | cut -d: -f7)
        if [[ "${current_home}" != "${expected_home}" ]]; then
            run_cmd "usermod -d ${expected_home} -m ${PODMAN_USER}"
        fi
        if [[ "${current_shell}" != "/usr/bin/nologin" ]]; then
            run_cmd "usermod -s /usr/bin/nologin ${PODMAN_USER}"
        fi
    else
        run_cmd "useradd -m -d ${expected_home} -s /usr/bin/nologin ${PODMAN_USER}"
        log_info "Created podman runtime user ${PODMAN_USER} with nologin shell"
    fi
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would lock password for ${PODMAN_USER}"
    else
        run_cmd "passwd -l ${PODMAN_USER}"
    fi
    if getent group ssh >/dev/null 2>&1; then
        run_cmd "gpasswd -d ${PODMAN_USER} ssh >/dev/null 2>&1 || true"
    fi
    if getent group wheel >/dev/null 2>&1; then
        run_cmd "gpasswd -d ${PODMAN_USER} wheel >/dev/null 2>&1 || true"
    fi
    run_cmd "install -d -m 0750 -o ${PODMAN_USER} -g ${PODMAN_USER} ${expected_home}"
    PODMAN_HOME=$(getent passwd "${PODMAN_USER}" | cut -d: -f6)
    if [[ -z "${PODMAN_HOME}" ]]; then
        if [[ ${DRY_RUN} -eq 1 ]]; then
            PODMAN_HOME="${expected_home}"
        else
            log_error "Unable to determine home for ${PODMAN_USER}"
            exit 1
        fi
    fi
    if ! loginctl enable-linger "${PODMAN_USER}" >/dev/null 2>&1; then
        log_warn "Could not enable linger for ${PODMAN_USER}; rootless services may not restart after reboot"
    fi
}

enable_timesync() {
    run_cmd "systemctl enable --now systemd-timesyncd.service"
}

ensure_firewall_backend() {
    if ! command -v nft >/dev/null 2>&1; then
        log_error "nft command not found; firewall configuration cannot continue."
        exit 1
    fi

    if nft list tables >/dev/null 2>&1; then
        return
    fi

    log_warn "nftables backend unavailable; attempting to load firewall kernel modules"
    local modules=()
    while IFS= read -r mod; do
        modules+=("${mod}")
    done < <(read_packages_from_file "${CONFIG_DIR}/firewall_modules.list")
    for mod in "${modules[@]}"; do
        if modinfo "${mod}" >/dev/null 2>&1; then
            run_cmd "modprobe ${mod} || true"
        fi
    done

    if nft list tables >/dev/null 2>&1; then
        log_info "Firewall kernel modules loaded successfully"
        return
    fi

    log_error "nftables backend still unavailable. Ensure firewall kernel modules are present or rerun with --skip-firewall-enable or --disable-firewall."
    exit 1
}

ensure_grub_defaults_saved() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would ensure /etc/default/grub has GRUB_DEFAULT=saved and GRUB_SAVEDEFAULT=true"
        return
    fi
    if [[ ! -f /etc/default/grub ]]; then
        log_error "/etc/default/grub not found; cannot set GRUB_DEFAULT/GRUB_SAVEDEFAULT."
        exit 1
    fi
    backup_file /etc/default/grub
    if grep -q '^GRUB_DEFAULT=' /etc/default/grub; then
        run_cmd "sed -i 's/^GRUB_DEFAULT=.*/GRUB_DEFAULT=saved/' /etc/default/grub"
    else
        run_cmd "echo 'GRUB_DEFAULT=saved' >> /etc/default/grub"
    fi
    if grep -q '^GRUB_SAVEDEFAULT=' /etc/default/grub; then
        run_cmd "sed -i 's/^GRUB_SAVEDEFAULT=.*/GRUB_SAVEDEFAULT=true/' /etc/default/grub"
    else
        run_cmd "echo 'GRUB_SAVEDEFAULT=true' >> /etc/default/grub"
    fi
}

ensure_lts_kernel_and_reboot_gate() {
    if ! command -v grub-mkconfig >/dev/null 2>&1; then
        log_error "grub-mkconfig not found; unable to set linux-lts as default."
        exit 1
    fi
    if ! command -v grub-set-default >/dev/null 2>&1; then
        log_error "grub-set-default not found; unable to set linux-lts as default."
        exit 1
    fi
    if ! command -v grub-editenv >/dev/null 2>&1; then
        log_error "grub-editenv not found; unable to verify default boot entry."
        exit 1
    fi

    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would fully upgrade, install linux-lts, regenerate GRUB, set default to '${GRUB_LTS_ENTRY}', verify grub-editenv, and require reboot before hardening."
        return
    fi

    local current_kernel saved_entry
    current_kernel=$(uname -r)
    saved_entry=$(grub-editenv list 2>/dev/null | awk -F= '/^saved_entry=/{print $2}' || true)

    if [[ "${current_kernel}" == *-lts ]] && [[ "${saved_entry}" == "${GRUB_LTS_ENTRY}" ]]; then
        log_info "System already booted into linux-lts with GRUB default set; continuing with hardening."
        return
    fi

    log_info "Pre-hardening: updating system and preparing linux-lts default boot entry."
    if ! {
        run_cmd "pacman -Syu --noconfirm"
        run_cmd "pacman -S --needed --noconfirm linux-lts"
        ensure_grub_defaults_saved
        run_cmd "grub-mkconfig -o ${GRUB_CONFIG_PATH}"
        run_cmd "grub-set-default \"${GRUB_LTS_ENTRY}\""
    }; then
        log_error "$(red "linux-lts installation failed; please review ${LOG_FILE}")"
        exit 1
    fi

    saved_entry=$(grub-editenv list 2>/dev/null | awk -F= '/^saved_entry=/{print $2}' || true)
    if [[ "${saved_entry}" != "${GRUB_LTS_ENTRY}" ]]; then
        log_error "Expected GRUB saved_entry '${GRUB_LTS_ENTRY}', but grub-editenv reported '${saved_entry:-<unset>}'"
        exit 1
    fi

    record_pending_args "$@"
    write_continue_service
    local resume_cmd="${INSTALL_BIN} --resume $(cat ${PENDING_ARGS_FILE})"
    log_warn "$(yellow "Reboot required: linux-lts installed and set as default. Rebooting will auto-resume hardening via systemd.")"
    log_info "Manual resume command: ${resume_cmd}"
    log_info "$(green "LTS kernel installed. Rebooting in 5 seconds...")"
    sleep 5
    run_cmd "reboot"
}

ensure_ssh_group() {
    if getent group ssh >/dev/null 2>&1; then
        local current_gid
        current_gid=$(getent group ssh | cut -d: -f3)
        if (( current_gid < 1000 )); then
            log_info "SSH access group 'ssh' already exists as a system group (gid ${current_gid})"
            return
        fi

        local new_gid
        if ! new_gid=$(next_available_system_gid); then
            log_error "Unable to find a free system gid (<1000) to convert 'ssh' group"
            exit 1
        fi

        run_cmd "groupmod -g ${new_gid} ssh"
        log_warn "Converted existing 'ssh' group to system gid ${new_gid}"
        return
    fi

    run_cmd "groupadd -r ssh"
    log_info "Created system group 'ssh' for SSH access control"
}

ensure_user_in_group() {
    local user="$1" group="$2"
    if ! id -u "${user}" >/dev/null 2>&1; then
        if [[ ${DRY_RUN} -eq 1 ]]; then
            log_info "[DRY-RUN] Would ensure ${user} is in group ${group}"
            return
        fi
        log_error "User ${user} does not exist; cannot add to ${group}"
        exit 1
    fi
    if id -nG "${user}" | tr ' ' '\n' | grep -qx "${group}"; then
        return
    fi
    run_cmd "usermod -aG ${group} ${user}"
    log_info "Added ${user} to ${group}"
}

error_trap() {
    local exit_code=$?
    local cmd=${BASH_COMMAND}
    local src=${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}
    local line=${BASH_LINENO[0]:-0}
    log_error "Command failed with exit ${exit_code} at ${src}:${line}: ${cmd}"
    log_error "See ${LOG_FILE} for details."
    exit ${exit_code}
}
trap 'error_trap' ERR

switch_to_phase1_logging() {
    if [[ "${CURRENT_PHASE}" == "phase1" ]]; then
        return
    fi
    CURRENT_PHASE="phase1"
    LOG_FILE="${PHASE1_LOG}"
    export LOG_FILE
    log_info "==== Starting Phase 1 actions (logging to ${LOG_FILE}) ===="
}

run_as_user() {
    local user="$1"; shift
    local cmd="$*"
    local uid runtime_dir
    uid=$(id -u "${user}")
    runtime_dir="/run/user/${uid}"
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] (as ${user}) ${cmd}"
        return 0
    fi
    run_cmd "install -d -m 0700 -o ${user} -g ${user} ${runtime_dir}"
    log_info "Running as ${user}: ${cmd}"
    set +e
    HOME=$(eval echo "~${user}") XDG_RUNTIME_DIR="${runtime_dir}" runuser -l "${user}" -c "${cmd}"
    local rc=$?
    set -e
    return ${rc}
}

ensure_podmin_user_manager() {
    local runtime_dir err_file err_msg
    if [[ ${ENSURED_PODMIN_MANAGER} -eq 1 ]]; then
        return 0
    fi
    if [[ -n "${PODMAN_UID}" ]]; then
        runtime_dir="/run/user/${PODMAN_UID}"
    else
        PODMAN_UID=$(id -u "${PODMAN_USER}")
        runtime_dir="/run/user/${PODMAN_UID}"
    fi
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Ensuring user manager for ${PODMAN_USER} (uid ${PODMAN_UID})"
        return 0
    fi
    if ! loginctl enable-linger "${PODMAN_USER}" >/dev/null 2>&1; then
        log_warn "Could not enable linger for ${PODMAN_USER}; rootless services may not persist across reboots"
    fi
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${runtime_dir}"
    err_file=$(mktemp)
    if ! systemctl start "user@${PODMAN_UID}.service" >/dev/null 2>"${err_file}"; then
        err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
        if [[ -n "${err_msg}" ]]; then
            log_warn "Could not start user@${PODMAN_UID}.service for ${PODMAN_USER}: ${err_msg}"
        fi
    fi
    rm -f "${err_file}"
    ENSURED_PODMIN_MANAGER=1
}

podmin_systemctl() {
    local uid runtime_dir err_file err_msg
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] (as ${PODMAN_USER}) systemctl --user --machine=${PODMAN_USER}@.host $*"
        return 0
    fi
    ensure_podmin_user_manager
    uid="${PODMAN_UID}"
    runtime_dir="/run/user/${uid}"

    err_file=$(mktemp)
    if systemctl --user --machine="${PODMAN_USER}@.host" "$@" >/dev/null 2>"${err_file}"; then
        rm -f "${err_file}"
        return 0
    fi
    err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
    rm -f "${err_file}"
    log_warn "podmin systemctl (machine) failed: ${err_msg:-unknown}; retrying with runtime dir bus"

    if [[ ! -S "${runtime_dir}/bus" ]]; then
        err_file=$(mktemp)
        if ! systemctl start "user@${uid}.service" >/dev/null 2>"${err_file}"; then
            err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
            if [[ -n "${err_msg}" ]]; then
                log_warn "Could not ensure user@${uid}.service for ${PODMAN_USER}: ${err_msg}"
            fi
        fi
        rm -f "${err_file}"
    fi

    err_file=$(mktemp)
    if XDG_RUNTIME_DIR="${runtime_dir}" DBUS_SESSION_BUS_ADDRESS="unix:path=${runtime_dir}/bus" runuser -u "${PODMAN_USER}" -- systemctl --user "$@" >/dev/null 2>"${err_file}"; then
        rm -f "${err_file}"
        return 0
    fi
    err_msg=$(tr -d '\r' < "${err_file}" | head -n1)
    rm -f "${err_file}"
    log_warn "podmin systemctl (fallback) failed: ${err_msg:-unknown}; rootless services may not be active"
    return 1
}

final_summary() {
    log_info "==== âœ… Hardening completed ===="
    local summary output_dir
    summary=$(
        cat <<EOF
âœ… Hardening completed successfully.
$( (( ENABLE_FIREWALL )) && echo "ðŸ”’ Firewall: configured (ufw)" || echo "ðŸ”“ Firewall: skipped")
$( (( ENABLE_FAIL2BAN )) && echo "ðŸ›¡ï¸ Fail2ban: enabled" || echo "ðŸ›¡ï¸ Fail2ban: skipped")
ðŸ§ Kernel: $(uname -r)
ðŸ“¦ Packages updated and installed.
ðŸ§° Templates installed to /usr/share/vps-harden/templates/containers
ðŸ“œ Log: ${LOG_FILE}
EOF
    )
    if [[ -n "${USER_NAME}" ]] && id -u "${USER_NAME}" >/dev/null 2>&1; then
        output_dir="/home/${USER_NAME}"
    else
        output_dir="/root"
    fi
    FINAL_LOG_FILE="${output_dir}/vps-harden.log"
    echo "${summary}" > "${FINAL_LOG_FILE}"
    if [[ -n "${USER_NAME}" ]] && id -u "${USER_NAME}" >/dev/null 2>&1; then
        chown "${USER_NAME}:${USER_NAME}" "${FINAL_LOG_FILE}"
    fi
    log_info "Summary written to ${FINAL_LOG_FILE}"
}

trigger_final_reboot() {
    log_warn "==== Phase 1 completed; system will reboot in 5 seconds to finalize services and quadlets ===="
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would reboot now to complete Phase 1"
        return
    fi
    sleep 5
    run_cmd "reboot"
}

install_packages() {
    local pkgs=()
    while IFS= read -r pkg; do
        pkgs+=("${pkg}")
    done < <(read_packages_from_file "${CONFIG_DIR}/packages.list")

    if [[ ${ENABLE_AUDITD} -eq 1 ]]; then
        while IFS= read -r pkg; do
            pkgs+=("${pkg}")
        done < <(read_packages_from_file "${CONFIG_DIR}/packages.auditd.list" 1)
    fi

    while IFS= read -r pkg; do
        pkgs+=("${pkg}")
    done < <(read_packages_from_file "${CONFIG_DIR}/packages.custom.list" 1)

    apply_package_replacements pkgs

    if [[ ${#pkgs[@]} -eq 0 ]]; then
        log_warn "No packages defined for installation; skipping package installation"
        return
    fi

    log_info "Updating system and installing packages: ${pkgs[*]}"
    run_cmd "pacman -Syu --noconfirm ${pkgs[*]}"
}

install_self() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would install archarden to ${INSTALL_PREFIX} and symlink to ${INSTALL_BIN}"
        return
    fi
    if [[ "${SCRIPT_DIR}" != "${INSTALL_PREFIX}" ]]; then
        mkdir -p "${INSTALL_PREFIX}"
        run_cmd "cp -a ${SCRIPT_DIR}/. ${INSTALL_PREFIX}/"
    fi
    run_cmd "install -m 0755 ${INSTALL_PREFIX}/harden ${INSTALL_BIN}"
}

next_available_system_gid() {
    local gid used
    mapfile -t used < <(getent group | awk -F: '{print $3}')
    for gid in $(seq 999 -1 100); do
        if ! printf '%s\n' "${used[@]}" | grep -qx "${gid}"; then
            echo "${gid}"
            return 0
        fi
    done
    return 1
}

resume_needs_restore() {
    local arg resume_present=0
    for arg in "$@"; do
        if [[ "${arg}" == "--resume" ]]; then
            resume_present=1
            break
        fi
    done
    if [[ ${resume_present} -eq 1 && $# -eq 1 ]]; then
        return 0
    fi
    return 1
}

parse_args() {
    RESUME_MODE=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --hostname) SYSTEM_HOSTNAME="$2"; shift 2;;
            --user) USER_NAME="$2"; shift 2;;
            --pubkey-file) PUBKEY_FILE="$2"; shift 2;;
            --pubkey) PUBKEY_VALUE="$2"; shift 2;;
            --version) show_version; exit 0;;
            --ssh-port) SSH_PORT="$2"; shift 2;;
            --restrict-ssh-cidr) RESTRICT_SSH_CIDR="$2"; shift 2;;
            --keep-ssh-22) KEEP_SSH_22=1; shift;;
            --enable-auditd) ENABLE_AUDITD=1; shift;;
            --disable-fail2ban) ENABLE_FAIL2BAN=0; shift;;
            --disable-firewall|--disable-ufw) ENABLE_FIREWALL=0; shift;;
            --skip-firewall-enable) SKIP_FIREWALL_ENABLE=1; shift;;
            --dry-run) DRY_RUN=1; shift;;
            --resume) RESUME_MODE=1; shift;;
            -h|--help) usage; exit 0;;
            *) log_error "Unknown option: $1"; usage; exit 1;;
        esac
    done
    export DRY_RUN
}

preflight() {
    require_root
    if [[ -z "${SYSTEM_HOSTNAME}" ]]; then
        log_error "--hostname is required."
        exit 1
    fi
    if [[ -z "${USER_NAME}" ]]; then
        log_error "--user is required."
        exit 1
    fi
    if [[ -z "${PUBKEY_FILE}" && -z "${PUBKEY_VALUE}" ]]; then
        log_error "Either --pubkey-file or --pubkey is required."
        exit 1
    fi
    if ! grep -qi 'arch' /etc/os-release; then
        log_error "This tool is intended for Arch Linux systems."
        exit 1
    fi
    if ! [[ ${SSH_PORT} =~ ^[0-9]+$ ]] || (( SSH_PORT < 1 || SSH_PORT > 65535 )); then
        log_error "Invalid --ssh-port '${SSH_PORT}'. Must be 1-65535."
        exit 1
    fi
    if [[ -n "${SSH_CONNECTION:-}" ]]; then
        SSH_CONNECTION_INFO=${SSH_CONNECTION}
        log_info "Running under SSH from ${SSH_CONNECTION_INFO}"
    else
        log_warn "Not running under SSH; lockout protections limited."
    fi
}

read_packages_from_file() {
    local file="$1" optional="${2:-0}"
    if [[ ! -f "${file}" ]]; then
        if [[ "${optional}" -eq 1 ]]; then
            log_warn "Optional package list not found: ${file}; skipping"
            return
        fi
        log_error "Required package list not found: ${file}"
        exit 1
    fi

    grep -Ev '^[[:space:]]*(#|$)' "${file}"
}

apply_package_replacements() {
    local packages_var="$1"
    local -n packages_ref=${packages_var}
    local replacements_file="${CONFIG_DIR}/packages.replacements.list"
    local -a replacements=()

    while IFS= read -r line; do
        replacements+=("${line}")
    done < <(read_packages_from_file "${replacements_file}" 1)

    if [[ ${#replacements[@]} -eq 0 ]]; then
        return
    fi

    local entry current replacement
    for entry in "${replacements[@]}"; do
        read -r current replacement <<<"${entry}"
        if [[ -z "${current}" || -z "${replacement}" ]]; then
            log_warn "Skipping malformed replacement entry: ${entry}"
            continue
        fi
        if ! package_requested "${replacement}" "${packages_var}"; then
            continue
        fi
        if package_installed "${current}"; then
            replace_package "${current}" "${replacement}"
        fi
    done
}

package_requested() {
    local target="$1"
    local -n packages_ref=$2
    local pkg
    for pkg in "${packages_ref[@]}"; do
        if [[ "${pkg}" == "${target}" ]]; then
            return 0
        fi
    done
    return 1
}

package_installed() {
    local pkg="$1"
    if command -v pacman >/dev/null 2>&1; then
        pacman -Q "${pkg}" >/dev/null 2>&1
        return $?
    fi
    log_error "Unsupported package manager; cannot check installation state for ${pkg}"
    exit 1
}

replace_package() {
    local current="$1" replacement="$2"
    if command -v pacman >/dev/null 2>&1; then
        log_info "Replacing installed package ${current} with ${replacement}"
        if ! run_cmd "pacman -S --noconfirm --needed ${replacement}"; then
            log_warn "Direct install failed; retrying by removing ${current} first"
            run_cmd "pacman -Rdd --noconfirm ${current}"
            run_cmd "pacman -S --noconfirm --needed ${replacement}"
        fi
        return
    fi
    log_error "Unsupported package manager; cannot replace ${current} with ${replacement}"
    exit 1
}

record_pending_args() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would record pending args to ${PENDING_ARGS_FILE}: $*"
        return
    fi
    mkdir -p "${STATE_DIR}"

    local persisted_pubkey=""
    if [[ -n "${PUBKEY_FILE}" ]]; then
        if [[ ! -f "${PUBKEY_FILE}" ]]; then
            log_error "Public key file not found: ${PUBKEY_FILE}"
            exit 1
        fi
        persisted_pubkey="${PERSISTED_PUBKEY_FILE}"
        run_cmd "install -D -m 0644 \"${PUBKEY_FILE}\" \"${persisted_pubkey}\""
        log_info "Persisted public key for resume at ${persisted_pubkey}"
    fi

    local -a resume_args=()
    while [[ $# -gt 0 ]]; do
        if [[ "$1" == "--pubkey-file" ]]; then
            if [[ $# -lt 2 ]]; then
                log_error "Missing value for --pubkey-file when recording pending args"
                exit 1
            fi
            resume_args+=("$1")
            if [[ -n "${persisted_pubkey}" ]]; then
                resume_args+=("${persisted_pubkey}")
            else
                resume_args+=("$2")
            fi
            shift 2
            continue
        fi
        resume_args+=("$1")
        shift
    done

    printf '%q ' "${resume_args[@]}" > "${PENDING_ARGS_FILE}"
    echo >> "${PENDING_ARGS_FILE}"
}

report_services() {
    log_info "Enabled services summary:"
    status_cmd "systemctl list-unit-files --type=service --state=enabled"
}

disable_units_from_config() {
    local list_file="${CONFIG_DIR}/disable-units.list"
    if [[ ! -f "${list_file}" ]]; then
        log_warn "Disable list missing at ${list_file}; skipping"
        return
    fi

    while IFS= read -r unit || [[ -n "${unit}" ]]; do
        unit=$(echo "${unit%%#*}" | sed -E 's/^[[:space:]]+//;s/[[:space:]]+$//')
        if [[ -z "${unit}" ]]; then
            continue
        fi
        if [[ "${unit}" == *cloud-init* ]]; then
            log_warn "Skipping cloud-init unit ${unit}"
            continue
        fi
        local state
        state=$(systemctl is-enabled "${unit}" 2>/dev/null | tr -d '\r' || true)
        if [[ -z "${state}" ]]; then
            log_warn "Could not determine enable state for ${unit}; skipping"
            continue
        fi
        case "${state}" in
            enabled|enabled-runtime)
                if ! run_cmd "systemctl disable --now ${unit}"; then
                    log_warn "Failed to disable ${unit}; please review manually"
                fi
                ;;
            indirect)
                if ! run_cmd "systemctl disable --now ${unit}"; then
                    log_warn "Indirect unit ${unit} could not be disabled cleanly; please review manually"
                fi
                ;;
            static|disabled)
                if systemctl is-active --quiet "${unit}"; then
                    systemctl stop "${unit}" >/dev/null 2>&1 || true
                fi
                if [[ "${state}" == "static" ]]; then
                    log_info "${unit} is static; cannot be disabled via systemctl. Skipped disable."
                fi
                if [[ "${unit}" == "archlinux-keyring-wkd-sync.service" ]]; then
                    if systemctl is-active --quiet "archlinux-keyring-wkd-sync.timer"; then
                        systemctl stop "archlinux-keyring-wkd-sync.timer" >/dev/null 2>&1 || true
                        log_info "Stopped archlinux-keyring-wkd-sync.timer while service is inactive"
                    fi
                fi
                ;;
            *)
                log_warn "Unexpected enable state '${state}' for ${unit}; skipped"
                ;;
        esac
    done < "${list_file}"
}

ensure_default_target() {
    run_cmd "systemctl set-default multi-user.target"
    run_cmd "systemctl get-default"
}

verify_podman_runtime() {
    local uid runtime_dir runtime_output
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would verify Podman runtime as ${PODMAN_USER}"
        return
    fi
    uid=$(id -u "${PODMAN_USER}")
    runtime_dir="/run/user/${uid}"
    run_cmd "install -d -m 0700 -o ${PODMAN_USER} -g ${PODMAN_USER} ${runtime_dir}"
    runtime_output=$(HOME="${PODMAN_HOME:-$(eval echo \"~${PODMAN_USER}\")}" XDG_RUNTIME_DIR="${runtime_dir}" runuser -u "${PODMAN_USER}" -- podman info --format '{{.Host.OCIRuntime.Name}}' 2>/dev/null || true)
    runtime_output=$(echo "${runtime_output}" | tr -d '\r')
    if [[ "${runtime_output}" != "runc" ]]; then
        log_warn "Podman runtime reported '${runtime_output:-<empty>}' for ${PODMAN_USER}; expected 'runc'. Ensure containers.conf is applied."
    else
        log_info "Podman runtime verified as '${runtime_output}' for ${PODMAN_USER}"
    fi
}

verify_zram_swap() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would verify zram swap priority"
        return
    fi
    local swap_output zram_priority swapfile_priority
    swap_output=$(swapon --show --noheadings --raw --bytes 2>/dev/null || true)
    if [[ -z "${swap_output}" ]]; then
        log_warn "No active swap devices reported; zram may not be active."
        return
    fi
    zram_priority=$(echo "${swap_output}" | awk '$1 ~ /zram0/ {print $4}' | head -n1)
    swapfile_priority=$(echo "${swap_output}" | awk '$1 ~ /swapfile/ {print $4}' | head -n1)
    if echo "${swap_output}" | grep -q '/dev/zram0'; then
        log_info "zram device detected in swap list."
    else
        log_warn "zram device /dev/zram0 not present in swap list."
    fi
    if [[ -n "${zram_priority}" && -n "${swapfile_priority}" ]]; then
        if (( zram_priority > swapfile_priority )); then
            log_info "zram priority (${zram_priority}) is higher than swapfile (${swapfile_priority})."
        else
            log_warn "zram priority (${zram_priority:-unset}) is not higher than swapfile (${swapfile_priority:-unset})."
        fi
    else
        log_warn "Could not determine swap priorities for zram and swapfile; review swapon output manually."
    fi
}

restore_sshd_dropins() {
    local restored=0 dropin latest_backup
    for dropin in "${SSHD_HARDENING_DROPIN}" "${SSHD_CRYPTO_DROPIN}"; do
        latest_backup=$(ls -1t "${dropin}".*.bak 2>/dev/null | head -n1 || true)
        if [[ -n "${latest_backup}" ]]; then
            run_cmd "cp -p ${latest_backup} ${dropin}"
            restored=1
        elif [[ -f "${dropin}" ]]; then
            run_cmd "rm -f ${dropin}"
            restored=1
            log_warn "Removed ${dropin} after failure; no backup was available."
        fi
    done
    if [[ ${restored} -eq 1 ]]; then
        log_warn "Restored previous sshd drop-ins from backups after failure."
    fi
    return ${restored}
}

log_sshd_effective_crypto() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would log effective sshd crypto configuration"
        return
    fi
    status_cmd "sshd -T | grep -E 'kexalgorithms|ciphers|macs|hostkeyalgorithms|pubkeyacceptedalgorithms' || true"
}

verify_sshd_port() {
    if ss -tulpn | grep -q ":${SSH_PORT}"; then
        return 0
    fi
    return 1
}

restart_sshd_and_verify() {
    if [ "${DRY_RUN}" -eq 0 ]; then
        if run_cmd "systemctl restart sshd"; then
            if verify_sshd_port; then
                log_sshd_effective_crypto
                return
            fi
            log_error "sshd is not listening on port ${SSH_PORT} after restart"
        else
            log_error "sshd restart failed"
        fi
        log_warn "Attempting to restore previous sshd configuration after restart failure"
        restore_sshd_dropins
        if sshd -t && run_cmd "systemctl restart sshd" && verify_sshd_port; then
            log_warn "Restored previous sshd drop-ins after restart failure"
            log_sshd_effective_crypto
            return
        fi
        log_error "Unable to recover sshd service after restart failure; manual intervention required."
        exit 1
    else
        log_info "[DRY-RUN] Would restart sshd and verify port ${SSH_PORT}"
    fi
}

rotate_sshd_host_keys() {
    local ts backup_dir rotation_failed=0
    ts=$(date -u '+%Y%m%d%H%M%S')
    backup_dir="${SSH_HOSTKEY_BACKUP_BASE}/${ts}"

    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would backup host keys to ${backup_dir}, regenerate with ssh-keygen -A, and restart sshd"
        return
    fi

    run_cmd "install -d -m 0700 ${backup_dir}"
    if ls /etc/ssh/ssh_host_* >/dev/null 2>&1; then
        run_cmd "cp -a /etc/ssh/ssh_host_* ${backup_dir}/"
        log_info "Backed up existing ssh host keys to ${backup_dir}"
    else
        log_warn "No existing ssh host keys found before rotation"
    fi

    if ! run_cmd "systemctl stop sshd"; then
        log_warn "Could not stop sshd for host key rotation; skipping rotation"
        return
    fi

    if ! run_cmd "rm -f /etc/ssh/ssh_host_*"; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! run_cmd "ssh-keygen -A"; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! run_cmd "systemctl start sshd"; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! sshd -t; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! systemctl is-active --quiet sshd; then
        rotation_failed=1
    fi
    if [[ ${rotation_failed} -eq 0 ]] && ! verify_sshd_port; then
        log_warn "sshd port verification failed after host key rotation"
        rotation_failed=1
    fi

    if [[ ${rotation_failed} -eq 0 ]]; then
        log_info "sshd is listening on port ${SSH_PORT} after host key rotation"
        log_warn "Host keys rotated. Clients will see a host key change and must update known_hosts."
        log_sshd_effective_crypto
        return
    fi

    log_warn "Host key rotation failed; attempting to restore previous keys from ${backup_dir}"
    run_cmd "rm -f /etc/ssh/ssh_host_*"
    if ls "${backup_dir}"/ssh_host_* >/dev/null 2>&1; then
        run_cmd "cp -a ${backup_dir}/ssh_host_* /etc/ssh/"
    fi
    if sshd -t && run_cmd "systemctl restart sshd" && verify_sshd_port; then
        log_warn "Restored previous sshd host keys after rotation failure."
        log_sshd_effective_crypto
        return
    fi
    log_error "Restoration after failed host key rotation did not succeed; sshd may be unavailable."
    exit 1
}

status_cmd() {
    local cmd="$*"
    log_info "Status: ${cmd}"
    eval "${cmd}"
}

status_report() {
    log_info "==== STATUS REPORT ===="
    status_cmd "ss -tulnp || true"
    if command -v ufw >/dev/null 2>&1; then
        status_cmd "ufw status verbose || true"
    fi
    if systemctl list-unit-files --type=service | grep -q fail2ban.service; then
        status_cmd "systemctl status fail2ban --no-pager || true"
    fi
    report_services
    if [[ ${#BACKUP_PATHS[@]} -gt 0 ]]; then
        log_info "Backups created: ${BACKUP_PATHS[*]}"
    fi
}

usage() {
    printf "%s\n" "$(bold "Usage:") $(cyan "sudo ./harden [options]")"
    printf "\n%s\n" "$(bold "$(green "Required")")"
    printf "  %s\n" "$(cyan "--hostname <name>")          Set the system hostname."
    printf "  %s\n" "$(cyan "--user <name>")              Create or ensure admin user exists and in wheel group."
    printf "  %s\n" "$(cyan "--pubkey-file <path>")       Public key file to install for the admin user."
    printf "  %s\n" "$(cyan "--pubkey \"<key>\"")           Public key string to install for the admin user."

    printf "\n%s\n" "$(bold "$(green "SSH")")"
    printf "  %s\n" "$(cyan "--ssh-port <port>")          SSH port to configure (default: 2122)."
    printf "  %s\n" "$(cyan "--restrict-ssh-cidr <C>")    Restrict SSH via UFW to the given CIDR."
    printf "  %s\n" "$(cyan "--keep-ssh-22")              Keep port 22 allowed (transition)."

    printf "\n%s\n" "$(bold "$(green "Optional services")")"
    printf "  %s\n" "$(cyan "--enable-auditd")            Install and enable auditd."
    printf "  %s\n" "$(cyan "--disable-fail2ban")         Skip fail2ban configuration."
    printf "  %s\n" "$(cyan "--disable-firewall")         Skip firewall configuration (alias: --disable-ufw)."
    printf "  %s\n" "$(cyan "--skip-firewall-enable")     Write UFW rules but do not enable the firewall."

    printf "\n%s\n" "$(bold "$(green "Behavior")")"
    printf "  %s\n" "$(cyan "--dry-run")                  Show actions without changing the system."
    printf "  %s\n" "$(cyan "--resume")                   Internal flag: resume after reboot; do not re-arm continuation."
    printf "  %s\n" "$(cyan "--version")                  Show version and exit."
    printf "  %s\n" "$(cyan "-h, --help")                 Show this help."
}

verify_nf_tables_after_reboot() {
    if [[ ${RESUME_MODE} -eq 0 ]]; then
        return
    fi
    status_cmd "lsmod | grep -E 'nf_tables|nfnetlink' || true"
}

write_continue_service() {
    if [[ ${DRY_RUN} -eq 1 ]]; then
        log_info "[DRY-RUN] Would install continuation service at ${CONTINUE_SERVICE}"
        return
    fi
    render_template "${CONTINUE_SERVICE_TEMPLATE}" "${CONTINUE_SERVICE}" \
        "PENDING_ARGS_FILE=${PENDING_ARGS_FILE}" \
        "INSTALL_PREFIX=${INSTALL_PREFIX}"
    run_cmd "systemctl daemon-reload"
    run_cmd "systemctl enable vps-harden-continue.service"
}

show_version() {
    local version_file="${SCRIPT_DIR}/VERSION"
    if [[ -f "${version_file}" ]]; then
        cat "${version_file}"
    else
        echo "unknown"
    fi
}

    main() {
        local answer_file="${SCRIPT_DIR}/harden.params" file_args cli_args cli_has_dry_run=0 file_has_dry_run=0

        cli_args=("$@")

        if [[ "$#" -gt 0 && "$1" == "--resume" ]]; then
            :
        else
            if [[ -f "${answer_file}" ]]; then
                file_args=$(sed -e 's/[[:space:]]*#.*$//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' "${answer_file}" | tr '\n' ' ')
                log_info "Using parameter file ${answer_file}; overriding CLI arguments"
                if [[ -n "${file_args//[[:space:]]/}" ]]; then
                    if [[ " ${file_args} " == *" --dry-run "* ]]; then
                        file_has_dry_run=1
                fi
                eval "set -- ${file_args}"
            else
                set --
            fi
        fi
    fi

    for arg in "${cli_args[@]}"; do
        if [[ "${arg}" == "--dry-run" ]]; then
            cli_has_dry_run=1
            break
        fi
    done
    if [[ ${cli_has_dry_run} -eq 1 && ${file_has_dry_run} -eq 0 ]]; then
        set -- "$@" --dry-run
    fi

    if resume_needs_restore "$@"; then
        if [[ ! -s "${PENDING_ARGS_FILE}" ]]; then
            log_error "Resume requested but pending args missing at ${PENDING_ARGS_FILE}"
            exit 1
        fi
        local saved_args
        saved_args=$(cat "${PENDING_ARGS_FILE}")
        log_info "Resume requested without parameters; restoring saved arguments from ${PENDING_ARGS_FILE}"
        eval "set -- --resume ${saved_args}"
    fi

    parse_args "$@"
    preflight
    install_self
    clear_pending_state
    ensure_lts_kernel_and_reboot_gate "$@"
    switch_to_phase1_logging
    verify_nf_tables_after_reboot
    install_packages
    enable_timesync
    configure_journald
    configure_sysctl
    configure_vm_tuning_sysctl
    apply_sysctl_settings
    configure_tmp_mount
    configure_zram
    configure_hostname
    ensure_ssh_group
    create_admin_user
    ensure_podmin_user
    configure_podman_runtime
    configure_sshd
    restart_sshd_and_verify
    rotate_sshd_host_keys
    configure_ufw
    configure_fail2ban
    configure_podman_templates
    configure_rootless_quadlets
    configure_socket_proxyd
    verify_podman_runtime
    verify_zram_swap
    ensure_default_target
    disable_units_from_config
    status_report
    final_summary
    trigger_final_reboot
}

main "$@"

show_version() {
    local version_file="${SCRIPT_DIR}/VERSION"
    if [[ -f "${version_file}" ]]; then
        cat "${version_file}"
    else
        echo "unknown"
    fi
}
